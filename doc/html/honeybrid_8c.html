<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>honeybrid: honeybrid.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>honeybrid.c File Reference</h1>Main File.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;sys/param.h&gt;</code><br>
<code>#include &lt;sys/stat.h&gt;</code><br>
<code>#include &lt;sys/types.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &lt;err.h&gt;</code><br>
<code>#include &lt;errno.h&gt;</code><br>
<code>#include &lt;syslog.h&gt;</code><br>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;fcntl.h&gt;</code><br>
<code>#include &lt;unistd.h&gt;</code><br>
<code>#include &lt;signal.h&gt;</code><br>
<code>#include &lt;malloc.h&gt;</code><br>
<code>#include &lt;netinet/in.h&gt;</code><br>
<code>#include &lt;linux/netfilter.h&gt;</code><br>
<code>#include &lt;libnetfilter_queue/libnetfilter_queue.h&gt;</code><br>
<code>#include &lt;arpa/inet.h&gt;</code><br>
<code>#include &lt;glib.h&gt;</code><br>
<code>#include &lt;execinfo.h&gt;</code><br>
<code>#include &lt;ev.h&gt;</code><br>
<code>#include &quot;<a class="el" href="tables_8h-source.html">tables.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="honeybrid_8h-source.html">honeybrid.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="netcode_8h-source.html">netcode.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="log_8h-source.html">log.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="decision__engine_8h-source.html">decision_engine.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="modules_8h-source.html">modules.h</a>&quot;</code><br>

<p>
<div class="dynheader">
Include dependency graph for honeybrid.c:</div>
<div class="dynsection">
<p><center><img src="honeybrid_8c__incl.png" border="0" usemap="#honeybrid.c_map" alt=""></center>
<map name="honeybrid.c_map">
<area shape="rect" href="tables_8h.html" title="tables.h" alt="" coords="661,161,733,188"><area shape="rect" href="modules_8h.html" title="modules.h" alt="" coords="696,316,784,343"><area shape="rect" href="log_8h.html" title="log.h" alt="" coords="880,393,931,420"><area shape="rect" href="honeybrid_8h.html" title="honeybrid.h" alt="" coords="1224,161,1320,188"><area shape="rect" href="netcode_8h.html" title="netcode.h" alt="" coords="859,84,944,111"><area shape="rect" href="decision__engine_8h.html" title="decision_engine.h" alt="" coords="547,84,683,111"><area shape="rect" href="types_8h.html" title="types.h" alt="" coords="956,239,1023,265"></map>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#d179db7b04bfd86a67a6a62a36bffdac">usage</a> (char **argv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">include "pcap_tool.h"  <a href="#d179db7b04bfd86a67a6a62a36bffdac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#c8f0a211851c2ba508ca6f725085d72e">print_trace</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a backtrace and print it to stdout.  <a href="#c8f0a211851c2ba508ca6f725085d72e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#f41f27390952cbd5bd9dd97466eb7270">close_thread</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function that waits for thread to close themselves.  <a href="#f41f27390952cbd5bd9dd97466eb7270"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#1b7c25c4ad0411c1b4dcb5601ab2ec8e">free_table</a> (gchar *key, gchar *value, gpointer data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to free memory in the different table created.  <a href="#1b7c25c4ad0411c1b4dcb5601ab2ec8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#5bbd513c2230553887d39c4bdc62ef4f">free_hash</a> (gchar *key, GHashTable *value, gpointer data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to free memory in the different subhash created.  <a href="#5bbd513c2230553887d39c4bdc62ef4f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#cbd9767e6d740fdf8fe76241355e7eb3">close_hash</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the different hashes used by honeybrid.  <a href="#cbd9767e6d740fdf8fe76241355e7eb3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#421d05d955ead3625ced86dccf934e3c">close_conn_tree</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to free memory taken by conn_tree.  <a href="#421d05d955ead3625ced86dccf934e3c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#41c4414e2f762a2fbc14703dba8933a0">free_target</a> (struct <a class="el" href="structtarget.html">target</a> *t, gpointer user_data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#65cd754c1e3cf01394c301f2d2519c62">close_target</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">destroy global structure "targets" when the program has to quit  <a href="#65cd754c1e3cf01394c301f2d2519c62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#4f52071c6670c301def21ad8af10f67b">close_all</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">destroy structures and free memory when the program has to quit  <a href="#4f52071c6670c301def21ad8af10f67b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#a5720f5313aaa546632b6be9708a2983">term_signal_handler</a> (int signal_nb, siginfo_t *siginfo, void *context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">called when the program receive a signal that should close the program, free memory and delete lock file  <a href="#a5720f5313aaa546632b6be9708a2983"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#43e4391ca50d9d5fb13dcd6d375528f2">switch_clean</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">call the <a class="el" href="structpacket.html">packet</a> cleaner  <a href="#43e4391ca50d9d5fb13dcd6d375528f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#e5bb595c918711b87a2016067c4a60ea">init_parser</a> (char *filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configuration parsing function, read the configuration from a specific file and parse it into a hash table or other <a class="el" href="structtree.html">tree</a> data structures using Bison/Flex.  <a href="#e5bb595c918711b87a2016067c4a60ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#9249da0285497dd291f2ea6a9ad37a64">init_variables</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">short int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#419a3099804011a842988e7be24d60dd">netlink_loop</a> (unsigned short int queuenum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to create and maintain the NF_QUEUE loop.  <a href="#419a3099804011a842988e7be24d60dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#6b180e7b938dc511f682253f924fd35a">init_signal</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">installs signal handlers  <a href="#6b180e7b938dc511f682253f924fd35a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="honeybrid_8c.html#0ddf1224851353fc92bfbff6f499fa97">main</a> (int argc, char *argv[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">process arguments, daemonize, init variables, create QUEUE handler and process each <a class="el" href="structpacket.html">packet</a>  <a href="#0ddf1224851353fc92bfbff6f499fa97"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Main File. 
<p>
This is the main program file for Honeybrid. It creates a hook using LibNetfilter Queue and, for each connection, maintain a stateful table. It forward a <a class="el" href="structpacket.html">packet</a> to a determined destination and submit this <a class="el" href="structpacket.html">packet</a> to the decision engine. When the decision engine decide to redirect a connection, this redirection engine replay the recorded connection to its new destination and maintain it until its end.<p>
Packets needs to be redirected to the QUEUE destination using netfilter, this can be done using: # iptables -A INPUT -j QUEUE &amp;&amp; iptables -A FORWARD -j QUEUE &amp;&amp; iptables -A OUTPUT -j QUEUE<p>
filters can also be set up using the regulars iptables capabilities, it is also recommended to limit the redirections to TCP and UDP packets (just add the option -p to the iptables commands)<p>
Dependencies:<ul>
<li>linux kernel &gt;= 2.6.18 &amp; &lt;=2.6.23</li><li>libnetfilter-queue-dev &amp; libnetfilter-queue1</li><li>libnfnetlink &gt;= 0.0.25</li><li>libglib2.0-dev &amp; libglib2.0-0</li></ul>
<p>
Known problem: If the buffer size under linux is too low, the IPQ subsystem will exit with the error "Failed to received netlink message: No buffer space available" To avoid that, increase the buffer value in /proc/sys/net/core/rmem_default (and rmem_max)<p>
J. Vehent, 2007  Thomas Coquelin, 2008  Robin Berthier, 2007-2009 <hr><h2>Function Documentation</h2>
<a class="anchor" name="4f52071c6670c301def21ad8af10f67b"></a><!-- doxytag: member="honeybrid.c::close_all" ref="4f52071c6670c301def21ad8af10f67b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_all           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
destroy structures and free memory when the program has to quit 
<p>
close_all 
<p>
delete lock file (only if the process ran as a daemon)<p>
wait for thread to close<p>
delete hashes<p>
delete conn_tree 
<p>References <a class="el" href="honeybrid_8c-source.html#l00272">close_conn_tree()</a>, <a class="el" href="honeybrid_8c-source.html#l00206">close_hash()</a>, <a class="el" href="honeybrid_8c-source.html#l00316">close_target()</a>, <a class="el" href="honeybrid_8c-source.html#l00159">close_thread()</a>, <a class="el" href="tables_8h-source.html#l00055">ICONFIG</a>, and <a class="el" href="honeybrid_8h-source.html#l00032">PIDFILE</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l01009">main()</a>.</p>

</div>
</div><p>
<a class="anchor" name="421d05d955ead3625ced86dccf934e3c"></a><!-- doxytag: member="honeybrid.c::close_conn_tree" ref="421d05d955ead3625ced86dccf934e3c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int close_conn_tree           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to free memory taken by conn_tree. 
<p>
close_conn_tree function 
<p>
clean the memory traverse the B-Tree to remove the singly linked lists and then destroy the B-Tree<p>
call the clean function for each value, delete the value if TRUE is returned<p>
remove each key listed from the btree<p>
free the array<p>
close log file 
<p>References <a class="el" href="log_8c-source.html#l00153">close_connection_log()</a>, <a class="el" href="tables_8h-source.html#l00088">conn_tree</a>, <a class="el" href="tables_8h-source.html#l00093">entrytoclean</a>, <a class="el" href="tables_8c-source.html#l00822">expire_conn()</a>, and <a class="el" href="tables_8c-source.html#l00876">free_conn()</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l00327">close_all()</a>.</p>

</div>
</div><p>
<a class="anchor" name="cbd9767e6d740fdf8fe76241355e7eb3"></a><!-- doxytag: member="honeybrid.c::close_hash" ref="cbd9767e6d740fdf8fe76241355e7eb3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int close_hash           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy the different hashes used by honeybrid. 
<p>
close_hash function 
<p>
Destroy hash tables<p>
this table generates invalid free error in valgrind<p>
and also a seg fault... g_print("close_hash():\tDestroying table DE_rules\n"); g_hash_table_foreach_remove(DE_rules, (GHRFunc) free_table, NULL); g_hash_table_destroy(DE_rules);
<p>References <a class="el" href="tables_8h-source.html#l00053">config</a>, <a class="el" href="decision__engine_8h-source.html#l00040">DE_rules</a>, <a class="el" href="honeybrid_8c-source.html#l00182">free_table()</a>, <a class="el" href="tables_8h-source.html#l00067">high_redirection_table</a>, and <a class="el" href="log_8h-source.html#l00097">log_table</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l00327">close_all()</a>.</p>

</div>
</div><p>
<a class="anchor" name="65cd754c1e3cf01394c301f2d2519c62"></a><!-- doxytag: member="honeybrid.c::close_target" ref="65cd754c1e3cf01394c301f2d2519c62" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int close_target           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
destroy global structure "targets" when the program has to quit 
<p>
close_target 
<p>References <a class="el" href="honeybrid_8c-source.html#l00299">free_target()</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, and <a class="el" href="tables_8h-source.html#l00042">targets</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l00327">close_all()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f41f27390952cbd5bd9dd97466eb7270"></a><!-- doxytag: member="honeybrid.c::close_thread" ref="f41f27390952cbd5bd9dd97466eb7270" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int close_thread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function that waits for thread to close themselves. 
<p>
close_thread 
<p>References <a class="el" href="tables_8h-source.html#l00147">NOK</a>, <a class="el" href="honeybrid_8h-source.html#l00094">thread_clean</a>, <a class="el" href="honeybrid_8h-source.html#l00095">thread_de</a>, and <a class="el" href="tables_8h-source.html#l00039">threading</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l00327">close_all()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5bbd513c2230553887d39c4bdc62ef4f"></a><!-- doxytag: member="honeybrid.c::free_hash" ref="5bbd513c2230553887d39c4bdc62ef4f" args="(gchar *key, GHashTable *value, gpointer data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int free_hash           </td>
          <td>(</td>
          <td class="paramtype">gchar *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GHashTable *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to free memory in the different subhash created. 
<p>
free_hash 
<p>References <a class="el" href="honeybrid_8c-source.html#l00182">free_table()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1b7c25c4ad0411c1b4dcb5601ab2ec8e"></a><!-- doxytag: member="honeybrid.c::free_table" ref="1b7c25c4ad0411c1b4dcb5601ab2ec8e" args="(gchar *key, gchar *value, gpointer data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int free_table           </td>
          <td>(</td>
          <td class="paramtype">gchar *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gchar *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to free memory in the different table created. 
<p>
free_table 
<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l00206">close_hash()</a>, and <a class="el" href="honeybrid_8c-source.html#l00194">free_hash()</a>.</p>

</div>
</div><p>
<a class="anchor" name="41c4414e2f762a2fbc14703dba8933a0"></a><!-- doxytag: member="honeybrid.c::free_target" ref="41c4414e2f762a2fbc14703dba8933a0" args="(struct target *t, gpointer user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_target           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtarget.html">target</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&nbsp;</td>
          <td class="paramname"> <em>user_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="types_8h-source.html#l00044">target::back_handler</a>, <a class="el" href="types_8h-source.html#l00045">target::back_rule</a>, <a class="el" href="types_8h-source.html#l00046">target::control_rule</a>, <a class="el" href="types_8h-source.html#l00041">target::filter</a>, <a class="el" href="types_8h-source.html#l00042">target::front_handler</a>, and <a class="el" href="types_8h-source.html#l00043">target::front_rule</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l00316">close_target()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e5bb595c918711b87a2016067c4a60ea"></a><!-- doxytag: member="honeybrid.c::init_parser" ref="e5bb595c918711b87a2016067c4a60ea" args="(char *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_parser           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configuration parsing function, read the configuration from a specific file and parse it into a hash table or other <a class="el" href="structtree.html">tree</a> data structures using Bison/Flex. 
<p>
parse_config 
<p>References <a class="el" href="err_8c-source.html#l00047">err()</a>, <a class="el" href="syntax_8c-source.html#l00345">yyin</a>, and <a class="el" href="rules_8c-source.html#l01176">yyparse()</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l01009">main()</a>.</p>

</div>
</div><p>
<a class="anchor" name="6b180e7b938dc511f682253f924fd35a"></a><!-- doxytag: member="honeybrid.c::init_signal" ref="6b180e7b938dc511f682253f924fd35a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_signal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
installs signal handlers 
<p>
init_signal <dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if exit with success, anything else if not </dd></dl>

<p>
Install terminating signal handler:<p>
SIGHUP<p>
SIGINT<p>
SIGQUIT<p>
SIGILL<p>
SIGSEGV<p>
SIGTERM<p>
SIGBUS<p>
ignore signals:<p>
SIGABRT<p>
SIGALRM<p>
SIGUSR2<p>
SIGPOLL<p>
rotate logs:<p>
SIGUSR1 
<p>References <a class="el" href="err_8c-source.html#l00076">errx()</a>, <a class="el" href="log_8c-source.html#l00188">rotate_connection_log()</a>, and <a class="el" href="honeybrid_8c-source.html#l00362">term_signal_handler()</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l01009">main()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9249da0285497dd291f2ea6a9ad37a64"></a><!-- doxytag: member="honeybrid.c::init_variables" ref="9249da0285497dd291f2ea6a9ad37a64" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_variables           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
create the hash table to store the config<p>
create the array of pointer to store the <a class="el" href="structtarget.html">target</a> information<p>
create the hash table to store module information<p>
create the hash table for the log engine<p>
create the hash table for the redirection table <dl compact><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>DEPRECATED if (NULL == (low_redirection_table = g_hash_table_new(g_str_hash, g_str_equal))) errx(1,"%s: Fatal error while creating redirection_table hash table.\n", __func__); </dd></dl>
<p>
create the hash table for the LIH list <dl compact><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>DEPRECATED if (NULL == (low_honeypot_addr = g_hash_table_new(g_int_hash, g_int_equal))) errx(1,"%s: Fatal error while creating low_honeypot_addr hash table.\n", __func__); </dd></dl>
<p>
create the hash table for the HIH list <dl compact><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>DEPRECATED if (NULL == (high_honeypot_addr = g_hash_table_new(g_int_hash, g_int_equal))) errx(1, "%s: Error while creating high_honeypot_addr hash table.\n", __func__); </dd></dl>
<p>
create the hash table to store the pointers to the boolean execution trees<p>
init the log singly linked list<p>
init the connection id counter<p>
Enable data processing<p>
init the security locks<p>
g_tree_new_full - create the main B-Tree to store meta informations of active connections<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>GCompareDataFunc,:</em>&nbsp;</td><td>function to compare 2 entries, we use strcmp </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>GDestroyNotify,:</em>&nbsp;</td><td>function called to destroy a key </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>GDestroyNotify,:</em>&nbsp;</td><td>function called to destroy a value </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new GTree.</dd></dl>

<p>References <a class="el" href="tables_8h-source.html#l00090">c_id</a>, <a class="el" href="tables_8h-source.html#l00053">config</a>, <a class="el" href="tables_8h-source.html#l00088">conn_tree</a>, <a class="el" href="decision__engine_8h-source.html#l00061">DE_queue</a>, <a class="el" href="decision__engine_8h-source.html#l00059">DE_queue_lock</a>, <a class="el" href="decision__engine_8h-source.html#l00040">DE_rules</a>, <a class="el" href="err_8c-source.html#l00076">errx()</a>, <a class="el" href="log_8h-source.html#l00076">log_list</a>, <a class="el" href="log_8h-source.html#l00097">log_table</a>, <a class="el" href="tables_8h-source.html#l00058">module</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, <a class="el" href="honeybrid_8h-source.html#l00089">running</a>, <a class="el" href="tables_8h-source.html#l00046">rwlock</a>, and <a class="el" href="tables_8h-source.html#l00042">targets</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l01009">main()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0ddf1224851353fc92bfbff6f499fa97"></a><!-- doxytag: member="honeybrid.c::main" ref="0ddf1224851353fc92bfbff6f499fa97" args="(int argc, char *argv[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>argv</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
process arguments, daemonize, init variables, create QUEUE handler and process each <a class="el" href="structpacket.html">packet</a> 
<p>
main <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>argc,number</em>&nbsp;</td><td>of arguments </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>argv,table</em>&nbsp;</td><td>with arguments</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if exit with success, anything else if not </dd></dl>

<p>
parsing arguments<p>
define configuration filename<p>
send a shutdown request to honeybrid<p>
convert argument to int<p>
check that processus exists<p>
send signal USR1 to PID<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>add a signal handler to output statistics (figure out the correct file description for output...) Statistics should include:<ul>
<li>version</li><li>start time and duration</li><li><a class="el" href="structpacket.html">packet</a> processed: total TCP UDP Other</li><li>connection processed: total INIT DECISION REPLAY FORWARD INVALID PROXY</li><li>decision engine, for each module: rules loaded signature loaded connection redirected (MATCH) connection left alone (DOES NOT MATCH)</li><li>errors NF_QUEUE restarts expected data</li><li>top ports?</li><li>top IP addresses? </li></ul>
</dd></dl>
<p>
init glib thread system<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>check if threads are correctly freed </dd></dl>
<p>
initialize signal handlers<p>
initialize syslog<p>
initialize data structures<p>
parse the configuration files and store values in memory<p>
Create PID file, we might not be able to remove it<p>
reopening file descriptor now that we're a daemon<p>
initiate outgoing connection control =&gt; no longer needed init_control();<p>
initiate decision engine modules =&gt; done automatically in rules.y, except for init_mod_hash:<p>
create the two raw sockets for UDP/IP and TCP/IP<p>
create a thread for the management, cleaning stuffs and so on<p>
Starting the nfqueue loop to start processing packets<p>
sometimes netlink_loop exits by itself... so we have to restart it int i = 0; while (running == OK) { netlink_loop(queuenum); g_printerr("%s Netlink loop exited (%d times so far)\n", <a class="el" href="log_8h.html#ee722791bac86c287527610799a9d221">H(0)</a>, i); g_usleep(1000000); i++; if (i&gt;100) { g_printerr("%s Reached maximum of 100 restarts... giving up\n", <a class="el" href="log_8h.html#ee722791bac86c287527610799a9d221">H(0)</a>); running = NOK; } }
<p>References <a class="el" href="honeybrid_8c-source.html#l00327">close_all()</a>, <a class="el" href="daemon_8c-source.html#l00045">daemon()</a>, <a class="el" href="decision__engine_8c-source.html#l00423">DE_submit_packet()</a>, <a class="el" href="err_8c-source.html#l00047">err()</a>, <a class="el" href="err_8c-source.html#l00076">errx()</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="tables_8h-source.html#l00055">ICONFIG</a>, <a class="el" href="modules_8c-source.html#l00054">init_modules()</a>, <a class="el" href="honeybrid_8c-source.html#l00432">init_parser()</a>, <a class="el" href="netcode_8c-source.html#l00457">init_raw_sockets()</a>, <a class="el" href="honeybrid_8c-source.html#l00927">init_signal()</a>, <a class="el" href="honeybrid_8c-source.html#l00449">init_variables()</a>, <a class="el" href="tables_8h-source.html#l00032">mainpid</a>, <a class="el" href="honeybrid_8c-source.html#l00778">netlink_loop()</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, <a class="el" href="log_8c-source.html#l00163">open_connection_log()</a>, <a class="el" href="log_8c-source.html#l00138">open_debug_log()</a>, <a class="el" href="honeybrid_8h-source.html#l00032">PIDFILE</a>, <a class="el" href="honeybrid_8c-source.html#l00392">switch_clean()</a>, <a class="el" href="netcode_8h-source.html#l00053">tcp_rsd</a>, <a class="el" href="honeybrid_8h-source.html#l00094">thread_clean</a>, <a class="el" href="honeybrid_8h-source.html#l00095">thread_de</a>, <a class="el" href="tables_8h-source.html#l00039">threading</a>, <a class="el" href="netcode_8h-source.html#l00053">udp_rsd</a>, <a class="el" href="honeybrid_8c-source.html#l00119">usage()</a>, and <a class="el" href="honeybrid_8h-source.html#l00029">VERSION</a>.</p>

</div>
</div><p>
<a class="anchor" name="419a3099804011a842988e7be24d60dd"></a><!-- doxytag: member="honeybrid.c::netlink_loop" ref="419a3099804011a842988e7be24d60dd" args="(unsigned short int queuenum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short int netlink_loop           </td>
          <td>(</td>
          <td class="paramtype">unsigned short int&nbsp;</td>
          <td class="paramname"> <em>queuenum</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to create and maintain the NF_QUEUE loop. 
<p>
netlink loop <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>queuenum</em>&nbsp;</td><td>the queue identifier </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>status </dd></dl>

<p>References <a class="el" href="honeybrid_8h-source.html#l00075">BUFSIZE</a>, <a class="el" href="err_8c-source.html#l00076">errx()</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="tables_8h-source.html#l00147">NOK</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, <a class="el" href="honeybrid_8h-source.html#l00081">PAYLOADSIZE</a>, and <a class="el" href="honeybrid_8h-source.html#l00089">running</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l01009">main()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c8f0a211851c2ba508ca6f725085d72e"></a><!-- doxytag: member="honeybrid.c::print_trace" ref="c8f0a211851c2ba508ca6f725085d72e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_trace           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain a backtrace and print it to stdout. 
<p>
print_trace 
<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l00362">term_signal_handler()</a>.</p>

</div>
</div><p>
<a class="anchor" name="43e4391ca50d9d5fb13dcd6d375528f2"></a><!-- doxytag: member="honeybrid.c::switch_clean" ref="43e4391ca50d9d5fb13dcd6d375528f2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void switch_clean           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
call the <a class="el" href="structpacket.html">packet</a> cleaner 
<p>
switch_clean 
<p>References <a class="el" href="tables_8c-source.html#l00892">clean()</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l01009">main()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a5720f5313aaa546632b6be9708a2983"></a><!-- doxytag: member="honeybrid.c::term_signal_handler" ref="a5720f5313aaa546632b6be9708a2983" args="(int signal_nb, siginfo_t *siginfo, void *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int term_signal_handler           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>signal_nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">siginfo_t *&nbsp;</td>
          <td class="paramname"> <em>siginfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
called when the program receive a signal that should close the program, free memory and delete lock file 
<p>
term_signal_handler<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>signal_nb,:</em>&nbsp;</td><td>number of the signal </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>siginfo,:</em>&nbsp;</td><td>informations regarding to the signal </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context,:</em>&nbsp;</td><td>NULL </td></tr>
  </table>
</dl>

<p>
this will cause the queue loop to stop 
<p>References <a class="el" href="tables_8h-source.html#l00147">NOK</a>, <a class="el" href="honeybrid_8c-source.html#l00138">print_trace()</a>, and <a class="el" href="honeybrid_8h-source.html#l00089">running</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l00927">init_signal()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d179db7b04bfd86a67a6a62a36bffdac"></a><!-- doxytag: member="honeybrid.c::usage" ref="d179db7b04bfd86a67a6a62a36bffdac" args="(char **argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usage           </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>argv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
include "pcap_tool.h" 
<p>
usage function print command line informations 
<p>References <a class="el" href="honeybrid_8h-source.html#l00029">VERSION</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l01009">main()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Feb 9 10:46:07 2010 for honeybrid by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
