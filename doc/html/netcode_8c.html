<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>honeybrid: netcode.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>netcode.c File Reference</h1>Network functions file.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;glib.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &lt;sys/socket.h&gt;</code><br>
<code>#include &lt;netinet/in.h&gt;</code><br>
<code>#include &lt;arpa/inet.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &quot;<a class="el" href="log_8h-source.html">log.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="tables_8h-source.html">tables.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="netcode_8h-source.html">netcode.h</a>&quot;</code><br>

<p>
<div class="dynheader">
Include dependency graph for netcode.c:</div>
<div class="dynsection">
<p><center><img src="netcode_8c__incl.png" border="0" usemap="#netcode.c_map" alt=""></center>
<map name="netcode.c_map">
<area shape="rect" href="log_8h.html" title="log.h" alt="" coords="43,393,93,420"><area shape="rect" href="tables_8h.html" title="tables.h" alt="" coords="233,161,305,188"><area shape="rect" href="netcode_8h.html" title="netcode.h" alt="" coords="304,84,389,111"><area shape="rect" href="types_8h.html" title="types.h" alt="" coords="400,239,467,265"><area shape="rect" href="modules_8h.html" title="modules.h" alt="" coords="168,316,256,343"></map>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="netcode_8c.html#5e4cd95c89adfdd7e4bdad48b0b7aa9f">in_cksum</a> (unsigned short *addr, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checksum routine for Internet Protocol family headers.  <a href="#5e4cd95c89adfdd7e4bdad48b0b7aa9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="netcode_8c.html#5b7827c561225b58a81718e27501307f">send_raw</a> (struct iphdr *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">send a <a class="el" href="structpacket.html">packet</a> over a raw socket  <a href="#5b7827c561225b58a81718e27501307f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="netcode_8c.html#f6f22be6ccd514e154f5e811188d051b">forward</a> (struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *pkt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">forward the <a class="el" href="structpacket.html">packet</a> to the attacker or to the HIH according to its origin  <a href="#f6f22be6ccd514e154f5e811188d051b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="netcode_8c.html#0a17e9db29ce866d9dbb3f8e000d4d88">reply_reset</a> (struct <a class="el" href="structpacket.html">packet</a> p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creat a RST <a class="el" href="structpacket.html">packet</a> from a unexepcted <a class="el" href="structpacket.html">packet</a> and sends it with send_raw  <a href="#0a17e9db29ce866d9dbb3f8e000d4d88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="netcode_8c.html#08b9f70de4ae79108619b003c98faa70">reset_lih</a> (struct <a class="el" href="structconn__struct.html">conn_struct</a> *conn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reset the LIH when redirected to HIH  <a href="#08b9f70de4ae79108619b003c98faa70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="netcode_8c.html#6f125882ee4dfbd1d35860549e962a67">replay</a> (struct <a class="el" href="structconn__struct.html">conn_struct</a> *conn, struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *pkt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reset the LIH when redirected to HIH  <a href="#6f125882ee4dfbd1d35860549e962a67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="netcode_8c.html#d578a8a62778555fafc3e1c85b67cc87">hb_ip_checksum</a> (struct iphdr *hdr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">update the checksum in the IP header  <a href="#d578a8a62778555fafc3e1c85b67cc87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="netcode_8c.html#097d65899a9a179c22b9a47c188a6618">udp_checksum</a> (struct <a class="el" href="structudp__packet.html">udp_packet</a> *hdr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">update the checksum in the UDP header  <a href="#097d65899a9a179c22b9a47c188a6618"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="netcode_8c.html#1c5840a3c34e17e78c5dff573966d75d">define_expected_data</a> (struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *pkt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">define expected <a class="el" href="structpacket.html">packet</a> from HIH according to the <a class="el" href="structpacket.html">packet</a> from LIH  <a href="#1c5840a3c34e17e78c5dff573966d75d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="netcode_8c.html#f444ee49d779a53c0a2f219a812bfa02">test_expected</a> (struct <a class="el" href="structconn__struct.html">conn_struct</a> *conn, struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *pkt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the <a class="el" href="structpacket.html">packet</a> from HIH, compare it to expected data, drop it and return the comparison result  <a href="#f444ee49d779a53c0a2f219a812bfa02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="netcode_8c.html#66fca3b08b64c478b6d91e83f2326628">init_raw_sockets</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create the two raw sockets for UDP/IP and TCP/IP  <a href="#66fca3b08b64c478b6d91e83f2326628"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="netcode_8c.html#76a1641651a94e4de2c397985c74ccd3">tcp_checksum</a> (struct <a class="el" href="structtcp__packet.html">tcp_packet</a> *pkt)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Network functions file. 
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Julien Vehent, 2007 <p>
Thomas Coquelin, 2008 </dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="1c5840a3c34e17e78c5dff573966d75d"></a><!-- doxytag: member="netcode.c::define_expected_data" ref="1c5840a3c34e17e78c5dff573966d75d" args="(struct pkt_struct *pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int define_expected_data           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>pkt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
define expected <a class="el" href="structpacket.html">packet</a> from HIH according to the <a class="el" href="structpacket.html">packet</a> from LIH 
<p>
define_expected_data<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pkt,:</em>&nbsp;</td><td><a class="el" href="structpacket.html">packet</a> metadata used </td></tr>
  </table>
</dl>

<p>References <a class="el" href="types_8h-source.html#l00212">pkt_struct::conn</a>, <a class="el" href="types_8h-source.html#l00126">hih_struct::delta</a>, <a class="el" href="types_8h-source.html#l00178">conn_struct::expected_data</a>, <a class="el" href="types_8h-source.html#l00180">conn_struct::hih</a>, <a class="el" href="types_8h-source.html#l00074">packet::ip</a>, <a class="el" href="types_8h-source.html#l00140">expected_data_struct::ip_proto</a>, <a class="el" href="types_8h-source.html#l00179">conn_struct::lock</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, <a class="el" href="types_8h-source.html#l00207">pkt_struct::packet</a>, <a class="el" href="types_8h-source.html#l00077">packet::payload</a>, <a class="el" href="types_8h-source.html#l00143">expected_data_struct::payload</a>, <a class="el" href="types_8h-source.html#l00075">packet::tcp</a>, <a class="el" href="types_8h-source.html#l00142">expected_data_struct::tcp_ack_seq</a>, and <a class="el" href="types_8h-source.html#l00141">expected_data_struct::tcp_seq</a>.</p>

<p>Referenced by <a class="el" href="netcode_8c-source.html#l00301">replay()</a>, and <a class="el" href="tables_8c-source.html#l00934">setup_redirection()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f6f22be6ccd514e154f5e811188d051b"></a><!-- doxytag: member="netcode.c::forward" ref="f6f22be6ccd514e154f5e811188d051b" args="(struct pkt_struct *pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int forward           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>pkt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
forward the <a class="el" href="structpacket.html">packet</a> to the attacker or to the HIH according to its origin 
<p>
forward<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pkt,the</em>&nbsp;</td><td><a class="el" href="structpacket.html">packet</a> metadata structure to forward</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>OK if the <a class="el" href="structpacket.html">packet</a> has been succesfully sent </dd></dl>

<p>
If <a class="el" href="structpacket.html">packet</a> from HIH, we forward if to EXT with LIH source<p>
We set LIH source IP<p>
If TCP, we update the source port, the sequence number, and the checksum<p>
If UDP, we update the source port and the checksum<p>
If <a class="el" href="structpacket.html">packet</a> from EXT, we forward if to HIH<p>
If <a class="el" href="structpacket.html">packet</a> from HIH, we forward if to EXT with LIH source<p>
If TCP, we update the destination port, the acknowledgement number if any, and the checksum<p>
If UDP, we update the destination port and the checksum<p>
we update the IP checksum and send the packect 
<p>References <a class="el" href="types_8h-source.html#l00123">hih_struct::addr</a>, <a class="el" href="types_8h-source.html#l00212">pkt_struct::conn</a>, <a class="el" href="types_8h-source.html#l00126">hih_struct::delta</a>, <a class="el" href="tables_8h-source.html#l00120">EXT</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="netcode_8c-source.html#l00361">hb_ip_checksum()</a>, <a class="el" href="types_8h-source.html#l00180">conn_struct::hih</a>, <a class="el" href="tables_8h-source.html#l00122">HIH</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="types_8h-source.html#l00074">packet::ip</a>, <a class="el" href="types_8h-source.html#l00127">hih_struct::lih_addr</a>, <a class="el" href="tables_8h-source.html#l00147">NOK</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, <a class="el" href="types_8h-source.html#l00208">pkt_struct::origin</a>, <a class="el" href="types_8h-source.html#l00207">pkt_struct::packet</a>, <a class="el" href="types_8h-source.html#l00124">hih_struct::port</a>, <a class="el" href="netcode_8c-source.html#l00087">send_raw()</a>, <a class="el" href="types_8h-source.html#l00094">tcp_packet::tcp</a>, <a class="el" href="types_8h-source.html#l00075">packet::tcp</a>, <a class="el" href="netcode_8c-source.html#l00475">tcp_checksum()</a>, and <a class="el" href="netcode_8c-source.html#l00374">udp_checksum()</a>.</p>

<p>Referenced by <a class="el" href="netcode_8c-source.html#l00301">replay()</a>, and <a class="el" href="tables_8c-source.html#l00934">setup_redirection()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d578a8a62778555fafc3e1c85b67cc87"></a><!-- doxytag: member="netcode.c::hb_ip_checksum" ref="d578a8a62778555fafc3e1c85b67cc87" args="(struct iphdr *hdr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hb_ip_checksum           </td>
          <td>(</td>
          <td class="paramtype">struct iphdr *&nbsp;</td>
          <td class="paramname"> <em>hdr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
update the checksum in the IP header 
<p>
hb_ip_checksum 
<p>References <a class="el" href="netcode_8c-source.html#l00050">in_cksum()</a>, and <a class="el" href="tables_8h-source.html#l00140">OK</a>.</p>

<p>Referenced by <a class="el" href="netcode_8c-source.html#l00149">forward()</a>, and <a class="el" href="netcode_8c-source.html#l00214">reply_reset()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5e4cd95c89adfdd7e4bdad48b0b7aa9f"></a><!-- doxytag: member="netcode.c::in_cksum" ref="5e4cd95c89adfdd7e4bdad48b0b7aa9f" args="(unsigned short *addr, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short in_cksum           </td>
          <td>(</td>
          <td class="paramtype">unsigned short *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checksum routine for Internet Protocol family headers. 
<p>
in_cksum <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>a pointer to the data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>len</em>&nbsp;</td><td>the 32 bits data size </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>sum a 16 bits checksum </dd></dl>

<p>
Our algorithm is simple, using a 32 bit accumulator (sum), we add sequential 16 bit words to it, and at the end, fold back all the carry bits from the top 16 bits into the lower 16 bits.<p>
mop up an odd byte, if necessary<p>
add back carry outs from top 16 bits to low 16 bits<p>
add hi 16 to low 16<p>
add carry<p>
truncate to 16 bits 
<p>Referenced by <a class="el" href="netcode_8c-source.html#l00361">hb_ip_checksum()</a>, <a class="el" href="netcode_8c-source.html#l00475">tcp_checksum()</a>, and <a class="el" href="netcode_8c-source.html#l00374">udp_checksum()</a>.</p>

</div>
</div><p>
<a class="anchor" name="66fca3b08b64c478b6d91e83f2326628"></a><!-- doxytag: member="netcode.c::init_raw_sockets" ref="66fca3b08b64c478b6d91e83f2326628" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int init_raw_sockets           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create the two raw sockets for UDP/IP and TCP/IP 
<p>
init_raw_sockets <dl class="return" compact><dt><b>Returns:</b></dt><dd>OK </dd></dl>

<p>
create the two raw sockets for UDP/IP and TCP/IP
<p>References <a class="el" href="tables_8h-source.html#l00140">OK</a>, <a class="el" href="netcode_8h-source.html#l00053">tcp_rsd</a>, and <a class="el" href="netcode_8h-source.html#l00053">udp_rsd</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l01009">main()</a>.</p>

</div>
</div><p>
<a class="anchor" name="6f125882ee4dfbd1d35860549e962a67"></a><!-- doxytag: member="netcode.c::replay" ref="6f125882ee4dfbd1d35860549e962a67" args="(struct conn_struct *conn, struct pkt_struct *pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int replay           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structconn__struct.html">conn_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reset the LIH when redirected to HIH 
<p>
replay<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>conn,:</em>&nbsp;</td><td>the connnection being replayed </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pkt,:</em>&nbsp;</td><td>the <a class="el" href="structpacket.html">packet</a> from HIH to test </td></tr>
  </table>
</dl>

<p>
If <a class="el" href="structpacket.html">packet</a> is from HIH and matches expected data then we replay the following packets from EXT to HIH until we find a <a class="el" href="structpacket.html">packet</a> from LIH<p>
Then we define expected data according to that <a class="el" href="structpacket.html">packet</a> 
<p>References <a class="el" href="types_8h-source.html#l00177">conn_struct::BUFFER</a>, <a class="el" href="types_8h-source.html#l00211">pkt_struct::DE</a>, <a class="el" href="netcode_8c-source.html#l00386">define_expected_data()</a>, <a class="el" href="tables_8h-source.html#l00120">EXT</a>, <a class="el" href="tables_8h-source.html#l00130">FORWARD</a>, <a class="el" href="netcode_8c-source.html#l00149">forward()</a>, <a class="el" href="tables_8c-source.html#l00339">free_pkt()</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="tables_8h-source.html#l00122">HIH</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="tables_8h-source.html#l00147">NOK</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, <a class="el" href="types_8h-source.html#l00208">pkt_struct::origin</a>, <a class="el" href="types_8h-source.html#l00174">conn_struct::replay_id</a>, <a class="el" href="tables_8c-source.html#l00223">switch_state()</a>, and <a class="el" href="netcode_8c-source.html#l00405">test_expected()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0a17e9db29ce866d9dbb3f8e000d4d88"></a><!-- doxytag: member="netcode.c::reply_reset" ref="0a17e9db29ce866d9dbb3f8e000d4d88" args="(struct packet p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int reply_reset           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpacket.html">packet</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creat a RST <a class="el" href="structpacket.html">packet</a> from a unexepcted <a class="el" href="structpacket.html">packet</a> and sends it with send_raw 
<p>
reply_reset<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p,the</em>&nbsp;</td><td><a class="el" href="structpacket.html">packet</a> to which we reply the reset <a class="el" href="structpacket.html">packet</a> </td></tr>
  </table>
</dl>

<p>
reset only tcp connections<p>
fill up the IP header<p>
fill up the TCP header 
<p>References <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="netcode_8c-source.html#l00361">hb_ip_checksum()</a>, <a class="el" href="types_8h-source.html#l00093">tcp_packet::ip</a>, <a class="el" href="types_8h-source.html#l00074">packet::ip</a>, <a class="el" href="tables_8h-source.html#l00147">NOK</a>, <a class="el" href="netcode_8c-source.html#l00087">send_raw()</a>, <a class="el" href="types_8h-source.html#l00075">packet::tcp</a>, and <a class="el" href="netcode_8c-source.html#l00475">tcp_checksum()</a>.</p>

</div>
</div><p>
<a class="anchor" name="08b9f70de4ae79108619b003c98faa70"></a><!-- doxytag: member="netcode.c::reset_lih" ref="08b9f70de4ae79108619b003c98faa70" args="(struct conn_struct *conn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int reset_lih           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structconn__struct.html">conn_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>conn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reset the LIH when redirected to HIH 
<p>
reset_lih<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>conn,:</em>&nbsp;</td><td>the connnection that the LIH reset </td></tr>
  </table>
</dl>

<p>
find last <a class="el" href="structpacket.html">packet</a> from LIH<p>
call <a class="el" href="netcode_8c.html#0a17e9db29ce866d9dbb3f8e000d4d88" title="creat a RST packet from a unexepcted packet and sends it with send_raw">reply_reset()</a> with this <a class="el" href="structpacket.html">packet</a> 
<p>References <a class="el" href="types_8h-source.html#l00177">conn_struct::BUFFER</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="types_8h-source.html#l00074">packet::ip</a>, <a class="el" href="tables_8h-source.html#l00121">LIH</a>, <a class="el" href="tables_8h-source.html#l00147">NOK</a>, <a class="el" href="types_8h-source.html#l00208">pkt_struct::origin</a>, and <a class="el" href="types_8h-source.html#l00207">pkt_struct::packet</a>.</p>

<p>Referenced by <a class="el" href="tables_8c-source.html#l00934">setup_redirection()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5b7827c561225b58a81718e27501307f"></a><!-- doxytag: member="netcode.c::send_raw" ref="5b7827c561225b58a81718e27501307f" args="(struct iphdr *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int send_raw           </td>
          <td>(</td>
          <td class="paramtype">struct iphdr *&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
send a <a class="el" href="structpacket.html">packet</a> over a raw socket 
<p>
send_raw <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p,the</em>&nbsp;</td><td><a class="el" href="structpacket.html">packet</a> structure that contains the <a class="el" href="structpacket.html">packet</a> to be sent </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>OK if the <a class="el" href="structpacket.html">packet</a> has been succesfully sent </dd></dl>

<p>
This line seg fault... sprintf(logbuf, "send_raw():\tSending raw packet from %s to %s\n", inet_ntoa(*(struct in_addr*)p-&gt;saddr), inet_ntoa(*(struct in_addr*)p-&gt;daddr));<p>
If TCP, use the TCP raw socket<p>
dst.sin_port = ((struct tcp_packet*)p)-&gt;tcp.dest;<p>
If UDP, use the UDP raw socket 
<p>References <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="tables_8h-source.html#l00147">NOK</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, <a class="el" href="netcode_8h-source.html#l00053">tcp_rsd</a>, and <a class="el" href="netcode_8h-source.html#l00053">udp_rsd</a>.</p>

<p>Referenced by <a class="el" href="netcode_8c-source.html#l00149">forward()</a>, and <a class="el" href="netcode_8c-source.html#l00214">reply_reset()</a>.</p>

</div>
</div><p>
<a class="anchor" name="76a1641651a94e4de2c397985c74ccd3"></a><!-- doxytag: member="netcode.c::tcp_checksum" ref="76a1641651a94e4de2c397985c74ccd3" args="(struct tcp_packet *pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tcp_checksum           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__packet.html">tcp_packet</a> *&nbsp;</td>
          <td class="paramname"> <em>pkt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
test for a new tcp checksum function <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pkt,:</em>&nbsp;</td><td><a class="el" href="structpacket.html">packet</a> to compute the checksum </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>OK </dd></dl>

<p>References <a class="el" href="netcode_8h-source.html#l00058">pseudotcphdr::daddr</a>, <a class="el" href="netcode_8c-source.html#l00050">in_cksum()</a>, <a class="el" href="types_8h-source.html#l00093">tcp_packet::ip</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, <a class="el" href="types_8h-source.html#l00095">tcp_packet::payload</a>, <a class="el" href="netcode_8h-source.html#l00068">tcp_chk_packet::payload</a>, <a class="el" href="netcode_8h-source.html#l00060">pseudotcphdr::proto</a>, <a class="el" href="netcode_8h-source.html#l00066">tcp_chk_packet::pseudohdr</a>, <a class="el" href="netcode_8h-source.html#l00059">pseudotcphdr::res1</a>, <a class="el" href="netcode_8h-source.html#l00057">pseudotcphdr::saddr</a>, <a class="el" href="netcode_8h-source.html#l00067">tcp_chk_packet::tcp</a>, <a class="el" href="types_8h-source.html#l00094">tcp_packet::tcp</a>, and <a class="el" href="netcode_8h-source.html#l00061">pseudotcphdr::tcp_len</a>.</p>

<p>Referenced by <a class="el" href="netcode_8c-source.html#l00149">forward()</a>, and <a class="el" href="netcode_8c-source.html#l00214">reply_reset()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f444ee49d779a53c0a2f219a812bfa02"></a><!-- doxytag: member="netcode.c::test_expected" ref="f444ee49d779a53c0a2f219a812bfa02" args="(struct conn_struct *conn, struct pkt_struct *pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_expected           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structconn__struct.html">conn_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get the <a class="el" href="structpacket.html">packet</a> from HIH, compare it to expected data, drop it and return the comparison result 
<p>
test_expected 
<p>
lock the structure g_static_rw_lock_writer_lock( &amp;conn-&gt;lock );<p>
free the lock g_static_rw_lock_writer_unlock( &amp;conn-&gt;lock );
<p>References <a class="el" href="types_8h-source.html#l00209">pkt_struct::data</a>, <a class="el" href="types_8h-source.html#l00178">conn_struct::expected_data</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="types_8h-source.html#l00074">packet::ip</a>, <a class="el" href="types_8h-source.html#l00140">expected_data_struct::ip_proto</a>, <a class="el" href="tables_8h-source.html#l00147">NOK</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, <a class="el" href="types_8h-source.html#l00207">pkt_struct::packet</a>, <a class="el" href="types_8h-source.html#l00143">expected_data_struct::payload</a>, <a class="el" href="types_8h-source.html#l00077">packet::payload</a>, <a class="el" href="types_8h-source.html#l00193">conn_struct::replay_problem</a>, <a class="el" href="types_8h-source.html#l00075">packet::tcp</a>, <a class="el" href="types_8h-source.html#l00142">expected_data_struct::tcp_ack_seq</a>, and <a class="el" href="types_8h-source.html#l00141">expected_data_struct::tcp_seq</a>.</p>

<p>Referenced by <a class="el" href="netcode_8c-source.html#l00301">replay()</a>.</p>

</div>
</div><p>
<a class="anchor" name="097d65899a9a179c22b9a47c188a6618"></a><!-- doxytag: member="netcode.c::udp_checksum" ref="097d65899a9a179c22b9a47c188a6618" args="(struct udp_packet *hdr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int udp_checksum           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudp__packet.html">udp_packet</a> *&nbsp;</td>
          <td class="paramname"> <em>hdr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
update the checksum in the UDP header 
<p>
udp_checksum 
<p>References <a class="el" href="netcode_8c-source.html#l00050">in_cksum()</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, and <a class="el" href="types_8h-source.html#l00111">udp_packet::udp</a>.</p>

<p>Referenced by <a class="el" href="netcode_8c-source.html#l00149">forward()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Feb 9 10:46:08 2010 for honeybrid by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
