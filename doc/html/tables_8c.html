<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>honeybrid: tables.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>tables.c File Reference</h1>Information tables file.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;netinet/tcp.h&gt;</code><br>
<code>#include &lt;netinet/ip.h&gt;</code><br>
<code>#include &lt;netinet/udp.h&gt;</code><br>
<code>#include &lt;arpa/inet.h&gt;</code><br>
<code>#include &lt;pcap.h&gt;</code><br>
<code>#include &lt;time.h&gt;</code><br>
<code>#include &lt;sys/time.h&gt;</code><br>
<code>#include &lt;unistd.h&gt;</code><br>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &lt;dumbnet.h&gt;</code><br>
<code>#include &lt;ctype.h&gt;</code><br>
<code>#include &quot;<a class="el" href="tables_8h-source.html">tables.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="log_8h-source.html">log.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="netcode_8h-source.html">netcode.h</a>&quot;</code><br>

<p>
<div class="dynheader">
Include dependency graph for tables.c:</div>
<div class="dynsection">
<p><center><img src="tables_8c__incl.png" border="0" usemap="#tables.c_map" alt=""></center>
<map name="tables.c_map">
<area shape="rect" href="tables_8h.html" title="tables.h" alt="" coords="463,161,535,188"><area shape="rect" href="log_8h.html" title="log.h" alt="" coords="300,393,351,420"><area shape="rect" href="netcode_8h.html" title="netcode.h" alt="" coords="232,84,317,111"><area shape="rect" href="types_8h.html" title="types.h" alt="" coords="352,239,419,265"><area shape="rect" href="modules_8h.html" title="modules.h" alt="" coords="419,316,507,343"></map>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#06fac303d39dbc9cead18f7d7197d449">CONCALLSIZE</a>&nbsp;&nbsp;&nbsp;2048</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of bytes of the buffer in the netfilter callback function  <a href="#06fac303d39dbc9cead18f7d7197d449"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#1c7647ec15cd2519ed93c9de272870d8">print_hex_ascii_line</a> (const u_char *payload, int len, int offset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#b48bc0458b0c2e1efb27f09c5ec679bb">print_payload</a> (const u_char *payload, int len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#fd88f5f9b2e1a96f07e2389659a868f8">lookup_proto</a> (int proto)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#1271052cd45b833fffe18a5a71c40fa5">lookup_origin</a> (int origin)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#5a8ba18af40b5d3be70aa2f237a44305">lookup_state</a> (int state)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#c710506076f7d599c11b9ee253507dbf">switch_state</a> (struct <a class="el" href="structconn__struct.html">conn_struct</a> *conn, int new_state)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#e4c96beae9b95707bbfdce40a54201b0">init_pkt</a> (char *nf_packet, struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *pkt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">init the current <a class="el" href="structpacket.html">packet</a> structure with meta-information such as the origin and the number of bytes of data  <a href="#e4c96beae9b95707bbfdce40a54201b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#4f340e483fb276ceab0a25388e915486">free_pkt</a> (struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *pkt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free the current <a class="el" href="structpacket.html">packet</a> structure  <a href="#4f340e483fb276ceab0a25388e915486"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#87e9230cc2f45d9b7cf40863772b5e0d">init_conn</a> (struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *pkt, struct <a class="el" href="structconn__struct.html">conn_struct</a> **conn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">init the current context using the tuples  <a href="#87e9230cc2f45d9b7cf40863772b5e0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#6bb715acc234b0176c7dc7b47f61ec6c">addr2int</a> (char *address)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert an IP address from string to int.  <a href="#6bb715acc234b0176c7dc7b47f61ec6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#23896331f26ea6a2d495f5eb08753976">test_honeypot_addr</a> (char *key, int list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compare an IP with a list of honeypot addresses  <a href="#23896331f26ea6a2d495f5eb08753976"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#9caa0904c4bad93cec860d3583503e60">lookup_honeypot_addr</a> (gchar *testkey, int list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the low/high interaction honeypot currently associated with the low/high interaction honeypot in argument  <a href="#9caa0904c4bad93cec860d3583503e60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#276fea9304d0e44959fe383a8a015826">store_pkt</a> (struct <a class="el" href="structconn__struct.html">conn_struct</a> *conn, struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *pkt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the current <a class="el" href="structpacket.html">packet</a> as part of the connection to replay it later. If this is the first <a class="el" href="structpacket.html">packet</a> of a communication, init its structure in the main B-Tree.  <a href="#276fea9304d0e44959fe383a8a015826"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#0c0c82c325e10d9d446035bfe36e0b12">expire_conn</a> (gpointer key, struct <a class="el" href="structconn__struct.html">conn_struct</a> *conn, gint *expiration_delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">called for each entry in the B-Tree, if a time value is upper to "expiration_delay" (default is 120 sec) and the connection is not marked as redirected, entry is deleted  <a href="#0c0c82c325e10d9d446035bfe36e0b12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#3b99286503ffeeb6930c555c55367455">free_conn</a> (gpointer key, gpointer trash)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">called for each entry in the pointer array, each entry is a key that is deleted from the B-Tree  <a href="#3b99286503ffeeb6930c555c55367455"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#2bbe646c052baf99f04a367ef6031d74">clean</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">watchman for the b_tree, wake up every 5 minutes and check every entries  <a href="#2bbe646c052baf99f04a367ef6031d74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#dcc1ca3626f4f77403029d5955299f79">setup_redirection</a> (struct <a class="el" href="structconn__struct.html">conn_struct</a> *conn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">called for each connection being redirected to setup and start the redirection process  <a href="#dcc1ca3626f4f77403029d5955299f79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tables_8c.html#8219bc2fff93a99b039dd539fbbf5477">config_lookup</a> (char *parameter)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Information tables file. 
<p>
In this file are defined the functions to manage packets. TBU<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Julien Vehent, 2007 <p>
Thomas Coquelin, 2008 </dd></dl>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="06fac303d39dbc9cead18f7d7197d449"></a><!-- doxytag: member="tables.c::CONCALLSIZE" ref="06fac303d39dbc9cead18f7d7197d449" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONCALLSIZE&nbsp;&nbsp;&nbsp;2048          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
number of bytes of the buffer in the netfilter callback function 
<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="6bb715acc234b0176c7dc7b47f61ec6c"></a><!-- doxytag: member="tables.c::addr2int" ref="6bb715acc234b0176c7dc7b47f61ec6c" args="(char *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int addr2int           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>address</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert an IP address from string to int. 
<p>
addr2int <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>the</em>&nbsp;</td><td>IP address (string format)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the IP address (int format) </dd></dl>

<p>References <a class="el" href="log_8h-source.html#l00100">H</a>.</p>

<p>Referenced by <a class="el" href="tables_8c-source.html#l00934">setup_redirection()</a>, and <a class="el" href="tables_8c-source.html#l00672">test_honeypot_addr()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2bbe646c052baf99f04a367ef6031d74"></a><!-- doxytag: member="tables.c::clean" ref="2bbe646c052baf99f04a367ef6031d74" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clean           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
watchman for the b_tree, wake up every 5 minutes and check every entries 
<p>
clean 
<p>
wake up every second<p>
init the table<p>
call the clean function for each value, delete the value if TRUE is returned<p>
remove each key listed from the btree<p>
free the array 
<p>References <a class="el" href="tables_8h-source.html#l00053">config</a>, <a class="el" href="tables_8h-source.html#l00088">conn_tree</a>, <a class="el" href="tables_8h-source.html#l00093">entrytoclean</a>, <a class="el" href="tables_8c-source.html#l00822">expire_conn()</a>, <a class="el" href="tables_8c-source.html#l00876">free_conn()</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, and <a class="el" href="tables_8h-source.html#l00039">threading</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l00392">switch_clean()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8219bc2fff93a99b039dd539fbbf5477"></a><!-- doxytag: member="tables.c::config_lookup" ref="8219bc2fff93a99b039dd539fbbf5477" args="(char *parameter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* config_lookup           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>parameter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
config_lookup /brief lookup values from the config hash table. Make sure the required value is present 
<p>References <a class="el" href="tables_8h-source.html#l00053">config</a>, and <a class="el" href="err_8c-source.html#l00076">errx()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0c0c82c325e10d9d446035bfe36e0b12"></a><!-- doxytag: member="tables.c::expire_conn" ref="0c0c82c325e10d9d446035bfe36e0b12" args="(gpointer key, struct conn_struct *conn, gint *expiration_delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int expire_conn           </td>
          <td>(</td>
          <td class="paramtype">gpointer&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structconn__struct.html">conn_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint *&nbsp;</td>
          <td class="paramname"> <em>expiration_delay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
called for each entry in the B-Tree, if a time value is upper to "expiration_delay" (default is 120 sec) and the connection is not marked as redirected, entry is deleted 
<p>
expire_conn <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key,a</em>&nbsp;</td><td>pointer to the current B-Tree key value </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>conn,a</em>&nbsp;</td><td>pointer to the current B-Tree associated value </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>expiration_delay</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE, to continue to traverse the <a class="el" href="structtree.html">tree</a> (if TRUE is returned, traversal is stopped) </dd></dl>

<p>
output final statistics about the connection<p>
lock the structure, this will never be unlocked<p>
remove the singly linked lists<p>
g_free(conn-&gt;key_hih); free(conn-&gt;decision_rule);<p>
list the entry for later removal 
<p>References <a class="el" href="types_8h-source.html#l00171">conn_struct::access_time</a>, <a class="el" href="types_8h-source.html#l00177">conn_struct::BUFFER</a>, <a class="el" href="log_8c-source.html#l00293">connection_log()</a>, <a class="el" href="types_8h-source.html#l00192">conn_struct::decision_rule</a>, <a class="el" href="tables_8h-source.html#l00093">entrytoclean</a>, <a class="el" href="tables_8c-source.html#l00339">free_pkt()</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="tables_8h-source.html#l00127">INIT</a>, <a class="el" href="types_8h-source.html#l00165">conn_struct::key_ext</a>, <a class="el" href="types_8h-source.html#l00166">conn_struct::key_lih</a>, <a class="el" href="types_8h-source.html#l00179">conn_struct::lock</a>, and <a class="el" href="types_8h-source.html#l00172">conn_struct::state</a>.</p>

<p>Referenced by <a class="el" href="tables_8c-source.html#l00892">clean()</a>, and <a class="el" href="honeybrid_8c-source.html#l00272">close_conn_tree()</a>.</p>

</div>
</div><p>
<a class="anchor" name="3b99286503ffeeb6930c555c55367455"></a><!-- doxytag: member="tables.c::free_conn" ref="3b99286503ffeeb6930c555c55367455" args="(gpointer key, gpointer trash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_conn           </td>
          <td>(</td>
          <td class="paramtype">gpointer&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&nbsp;</td>
          <td class="paramname"> <em>trash</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
called for each entry in the pointer array, each entry is a key that is deleted from the B-Tree 
<p>
free_conn <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key,a</em>&nbsp;</td><td>pointer to the current B-Tree key value stored in the pointer table </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>trash,user</em>&nbsp;</td><td>data, unused </td></tr>
  </table>
</dl>

<p>References <a class="el" href="tables_8h-source.html#l00088">conn_tree</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, and <a class="el" href="tables_8h-source.html#l00046">rwlock</a>.</p>

<p>Referenced by <a class="el" href="tables_8c-source.html#l00892">clean()</a>, and <a class="el" href="honeybrid_8c-source.html#l00272">close_conn_tree()</a>.</p>

</div>
</div><p>
<a class="anchor" name="4f340e483fb276ceab0a25388e915486"></a><!-- doxytag: member="tables.c::free_pkt" ref="4f340e483fb276ceab0a25388e915486" args="(struct pkt_struct *pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int free_pkt           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>pkt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free the current <a class="el" href="structpacket.html">packet</a> structure 
<p>
free_pkt <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pkt,:</em>&nbsp;</td><td>struct <a class="el" href="structpkt__struct.html" title="The meta information of a packet stored in the conn_struct connection structure.">pkt_struct</a> to free </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>OK </dd></dl>

<p>References <a class="el" href="types_8h-source.html#l00078">packet::FRAME</a>, <a class="el" href="types_8h-source.html#l00074">packet::ip</a>, <a class="el" href="types_8h-source.html#l00215">pkt_struct::key</a>, <a class="el" href="types_8h-source.html#l00214">pkt_struct::key_dst</a>, <a class="el" href="types_8h-source.html#l00213">pkt_struct::key_src</a>, <a class="el" href="tables_8h-source.html#l00147">NOK</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, and <a class="el" href="types_8h-source.html#l00207">pkt_struct::packet</a>.</p>

<p>Referenced by <a class="el" href="tables_8c-source.html#l00822">expire_conn()</a>, and <a class="el" href="netcode_8c-source.html#l00301">replay()</a>.</p>

</div>
</div><p>
<a class="anchor" name="87e9230cc2f45d9b7cf40863772b5e0d"></a><!-- doxytag: member="tables.c::init_conn" ref="87e9230cc2f45d9b7cf40863772b5e0d" args="(struct pkt_struct *pkt, struct conn_struct **conn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int init_conn           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structconn__struct.html">conn_struct</a> **&nbsp;</td>
          <td class="paramname"> <em>conn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
init the current context using the tuples 
<p>
init_conn <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pkt,:</em>&nbsp;</td><td>struct <a class="el" href="structpkt__struct.html" title="The meta information of a packet stored in the conn_struct connection structure.">pkt_struct</a> to work with </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>conn,:</em>&nbsp;</td><td>struct <a class="el" href="structconn__struct.html" title="The meta informations of a connection stored in the main Binary Tree.">conn_struct</a> to work with </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if success, anything else otherwise </dd></dl>

<p>
Get current time to update or create the structure<p>
if key-&gt;str is null, then we have a seg fault! And it can happen if no LIH was found from a HIH-&gt;EXT <a class="el" href="structpacket.html">packet</a>... if ( pkt-&gt;key == NULL ) { g_printerr("%s key is NULL, no valid connection attached\n", <a class="el" href="log_8h.html#ee722791bac86c287527610799a9d221">H(4)</a>); return NOK; }<p>
The key could not be found, so we need to figure out where this <a class="el" href="structpacket.html">packet</a> comes from<p>
Try to match a <a class="el" href="structtarget.html">target</a> with this <a class="el" href="structpacket.html">packet</a><p>
If not, then it means the packets is either originated from a honeypot inside (we control) or from a non supported external host (we drop)<p>
check if the src is in the honeynet<p>
if not, then this <a class="el" href="structpacket.html">packet</a> is for an unconfigured <a class="el" href="structtarget.html">target</a>, we drop it<p>
IPs match, we can proceed<p>
destination address is not the LIH address, so we drop the <a class="el" href="structpacket.html">packet</a> (later we might NAT <dl compact><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>) </dd></dl>
<p>
Init new connection structure<p>
fill the structure<p>
statistics<p>
conn_init-&gt;decision_rule = malloc(512);<p>
insert entry in B-Tree (set up a lock to protect the writing)<p>
free the lock<p>
store new entry in current struct<p>
The key was found in the B-Tree<p>
We store control statistics in the proxy mode<p>
statistics<p>
We update the current connection access time 
<p>References <a class="el" href="types_8h-source.html#l00171">conn_struct::access_time</a>, <a class="el" href="types_8h-source.html#l00177">conn_struct::BUFFER</a>, <a class="el" href="tables_8h-source.html#l00090">c_id</a>, <a class="el" href="types_8h-source.html#l00212">pkt_struct::conn</a>, <a class="el" href="tables_8h-source.html#l00088">conn_tree</a>, <a class="el" href="tables_8h-source.html#l00133">CONTROL</a>, <a class="el" href="types_8h-source.html#l00176">conn_struct::count_data_pkt_from_intruder</a>, <a class="el" href="types_8h-source.html#l00175">conn_struct::count_data_pkt_from_lih</a>, <a class="el" href="types_8h-source.html#l00192">conn_struct::decision_rule</a>, <a class="el" href="types_8h-source.html#l00126">hih_struct::delta</a>, <a class="el" href="types_8h-source.html#l00032">ETHER_HDR_LEN</a>, <a class="el" href="tables_8h-source.html#l00120">EXT</a>, <a class="el" href="types_8h-source.html#l00078">packet::FRAME</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="tables_8h-source.html#l00067">high_redirection_table</a>, <a class="el" href="types_8h-source.html#l00180">conn_struct::hih</a>, <a class="el" href="tables_8h-source.html#l00122">HIH</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="tables_8h-source.html#l00127">INIT</a>, <a class="el" href="tables_8h-source.html#l00126">INVALID</a>, <a class="el" href="types_8h-source.html#l00194">conn_struct::invalid_problem</a>, <a class="el" href="types_8h-source.html#l00074">packet::ip</a>, <a class="el" href="types_8h-source.html#l00164">conn_struct::key</a>, <a class="el" href="types_8h-source.html#l00215">pkt_struct::key</a>, <a class="el" href="types_8h-source.html#l00214">pkt_struct::key_dst</a>, <a class="el" href="types_8h-source.html#l00165">conn_struct::key_ext</a>, <a class="el" href="types_8h-source.html#l00167">conn_struct::key_hih</a>, <a class="el" href="types_8h-source.html#l00166">conn_struct::key_lih</a>, <a class="el" href="types_8h-source.html#l00213">pkt_struct::key_src</a>, <a class="el" href="tables_8h-source.html#l00121">LIH</a>, <a class="el" href="types_8h-source.html#l00125">hih_struct::lih_syn_seq</a>, <a class="el" href="types_8h-source.html#l00179">conn_struct::lock</a>, <a class="el" href="tables_8h-source.html#l00147">NOK</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, <a class="el" href="types_8h-source.html#l00208">pkt_struct::origin</a>, <a class="el" href="types_8h-source.html#l00207">pkt_struct::packet</a>, <a class="el" href="types_8h-source.html#l00168">conn_struct::protocol</a>, <a class="el" href="tables_8h-source.html#l00131">PROXY</a>, <a class="el" href="types_8h-source.html#l00174">conn_struct::replay_id</a>, <a class="el" href="types_8h-source.html#l00193">conn_struct::replay_problem</a>, <a class="el" href="tables_8h-source.html#l00046">rwlock</a>, <a class="el" href="types_8h-source.html#l00210">pkt_struct::size</a>, <a class="el" href="types_8h-source.html#l00170">conn_struct::start_microtime</a>, <a class="el" href="types_8h-source.html#l00169">conn_struct::start_timestamp</a>, <a class="el" href="types_8h-source.html#l00187">conn_struct::stat_byte</a>, <a class="el" href="types_8h-source.html#l00186">conn_struct::stat_packet</a>, <a class="el" href="types_8h-source.html#l00185">conn_struct::stat_time</a>, <a class="el" href="types_8h-source.html#l00172">conn_struct::state</a>, <a class="el" href="types_8h-source.html#l00182">conn_struct::target</a>, <a class="el" href="tables_8h-source.html#l00042">targets</a>, <a class="el" href="types_8h-source.html#l00075">packet::tcp</a>, <a class="el" href="types_8h-source.html#l00189">conn_struct::total_byte</a>, and <a class="el" href="types_8h-source.html#l00188">conn_struct::total_packet</a>.</p>

</div>
</div><p>
<a class="anchor" name="e4c96beae9b95707bbfdce40a54201b0"></a><!-- doxytag: member="tables.c::init_pkt" ref="e4c96beae9b95707bbfdce40a54201b0" args="(char *nf_packet, struct pkt_struct *pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int init_pkt           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>nf_packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
init the current <a class="el" href="structpacket.html">packet</a> structure with meta-information such as the origin and the number of bytes of data 
<p>
init_pkt <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nf_packet,:</em>&nbsp;</td><td>The raw <a class="el" href="structpacket.html">packet</a> from the queue </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pkt,:</em>&nbsp;</td><td>The <a class="el" href="structpacket.html">packet</a> metadata structure for this <a class="el" href="structpacket.html">packet</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the origin of the <a class="el" href="structpacket.html">packet</a> </dd></dl>

<p>
TODO: check if it's correctly freed<p>
Create fake ethernet header (used later by bpf_filter)<p>
The most important part is to give to this ethernet header the type "IP protocol"<p>
Add the <a class="el" href="structpacket.html">packet</a> IP header and payload to the <a class="el" href="structpacket.html">packet</a> structure<p>
THOMAS:Let's save memory!<p>
Process TCP packets<p>
key_src is the tuple with the source information {Source IP}:{Source Port}<p>
key_dst is the one with the destination information {Dest IP}:{Dest Port}<p>
Process UDP <a class="el" href="structpacket.html">packet</a><p>
key_src<p>
key_dst<p>
Every other packets are ignored 
<p>References <a class="el" href="types_8h-source.html#l00209">pkt_struct::data</a>, <a class="el" href="types_8h-source.html#l00211">pkt_struct::DE</a>, <a class="el" href="types_8h-source.html#l00032">ETHER_HDR_LEN</a>, <a class="el" href="tables_8h-source.html#l00120">EXT</a>, <a class="el" href="types_8h-source.html#l00078">packet::FRAME</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="types_8h-source.html#l00074">packet::ip</a>, <a class="el" href="types_8h-source.html#l00215">pkt_struct::key</a>, <a class="el" href="types_8h-source.html#l00214">pkt_struct::key_dst</a>, <a class="el" href="types_8h-source.html#l00213">pkt_struct::key_src</a>, <a class="el" href="tables_8h-source.html#l00147">NOK</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, <a class="el" href="types_8h-source.html#l00208">pkt_struct::origin</a>, <a class="el" href="types_8h-source.html#l00207">pkt_struct::packet</a>, <a class="el" href="types_8h-source.html#l00077">packet::payload</a>, <a class="el" href="types_8h-source.html#l00216">pkt_struct::position</a>, <a class="el" href="types_8h-source.html#l00210">pkt_struct::size</a>, <a class="el" href="types_8h-source.html#l00075">packet::tcp</a>, and <a class="el" href="types_8h-source.html#l00076">packet::udp</a>.</p>

</div>
</div><p>
<a class="anchor" name="9caa0904c4bad93cec860d3583503e60"></a><!-- doxytag: member="tables.c::lookup_honeypot_addr" ref="9caa0904c4bad93cec860d3583503e60" args="(gchar *testkey, int list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* lookup_honeypot_addr           </td>
          <td>(</td>
          <td class="paramtype">gchar *&nbsp;</td>
          <td class="paramname"> <em>testkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
return the low/high interaction honeypot currently associated with the low/high interaction honeypot in argument 
<p>
lookup_honeypot_addr<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>the</em>&nbsp;</td><td>key of the honeypot, or honeypot+external host, we want to lookup in the redirection table </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>the</em>&nbsp;</td><td>list we want to look into, either Low or High</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The honeypot IP found, NULL if nothing is found </dd></dl>

<p>
We test which list we want to search<p>
ROBIN 2009-02-25: small hack to include full network definition<p>
get the corresponding hih destination from the low interaction hash table<p>
get the corresponding lih destination from the high interaction hash table<p>
Check first if the high_redirection_table is not null 
<p>References <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="tables_8h-source.html#l00067">high_redirection_table</a>, <a class="el" href="tables_8h-source.html#l00121">LIH</a>, and <a class="el" href="tables_8h-source.html#l00064">low_redirection_table</a>.</p>

</div>
</div><p>
<a class="anchor" name="1271052cd45b833fffe18a5a71c40fa5"></a><!-- doxytag: member="tables.c::lookup_origin" ref="1271052cd45b833fffe18a5a71c40fa5" args="(int origin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* lookup_origin           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>origin</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="tables_8h-source.html#l00120">EXT</a>, <a class="el" href="tables_8h-source.html#l00122">HIH</a>, and <a class="el" href="tables_8h-source.html#l00121">LIH</a>.</p>

</div>
</div><p>
<a class="anchor" name="fd88f5f9b2e1a96f07e2389659a868f8"></a><!-- doxytag: member="tables.c::lookup_proto" ref="fd88f5f9b2e1a96f07e2389659a868f8" args="(int proto)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* lookup_proto           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>proto</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5a8ba18af40b5d3be70aa2f237a44305"></a><!-- doxytag: member="tables.c::lookup_state" ref="5a8ba18af40b5d3be70aa2f237a44305" args="(int state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* lookup_state           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="tables_8h-source.html#l00133">CONTROL</a>, <a class="el" href="tables_8h-source.html#l00128">DECISION</a>, <a class="el" href="tables_8h-source.html#l00132">DROP</a>, <a class="el" href="tables_8h-source.html#l00130">FORWARD</a>, <a class="el" href="tables_8h-source.html#l00127">INIT</a>, <a class="el" href="tables_8h-source.html#l00126">INVALID</a>, <a class="el" href="tables_8h-source.html#l00131">PROXY</a>, and <a class="el" href="tables_8h-source.html#l00129">REPLAY</a>.</p>

<p>Referenced by <a class="el" href="tables_8c-source.html#l00223">switch_state()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1c7647ec15cd2519ed93c9de272870d8"></a><!-- doxytag: member="tables.c::print_hex_ascii_line" ref="1c7647ec15cd2519ed93c9de272870d8" args="(const u_char *payload, int len, int offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_hex_ascii_line           </td>
          <td>(</td>
          <td class="paramtype">const u_char *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="tables_8c-source.html#l00116">print_payload()</a>.</p>

</div>
</div><p>
<a class="anchor" name="b48bc0458b0c2e1efb27f09c5ec679bb"></a><!-- doxytag: member="tables.c::print_payload" ref="b48bc0458b0c2e1efb27f09c5ec679bb" args="(const u_char *payload, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_payload           </td>
          <td>(</td>
          <td class="paramtype">const u_char *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
print_payload 
<p>References <a class="el" href="tables_8c-source.html#l00065">print_hex_ascii_line()</a>.</p>

</div>
</div><p>
<a class="anchor" name="dcc1ca3626f4f77403029d5955299f79"></a><!-- doxytag: member="tables.c::setup_redirection" ref="dcc1ca3626f4f77403029d5955299f79" args="(struct conn_struct *conn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setup_redirection           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structconn__struct.html">conn_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>conn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
called for each connection being redirected to setup and start the redirection process 
<p>
setup_redirection <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>conn,:</em>&nbsp;</td><td>redirected connection metadata </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>OK when done, NOK in case of failure </dd></dl>

<p>
we check for concurrent connections using the same EXT_IP:PORT &lt;-&gt; HIH_IP:PORT<p>
conn-&gt;key_hih = hihaddr;<p>
We then update the status of the connection structure<p>
We reset the LIH<p>
We replay the first packets 
<p>References <a class="el" href="types_8h-source.html#l00123">hih_struct::addr</a>, <a class="el" href="tables_8c-source.html#l00643">addr2int()</a>, <a class="el" href="types_8h-source.html#l00044">target::back_handler</a>, <a class="el" href="types_8h-source.html#l00177">conn_struct::BUFFER</a>, <a class="el" href="tables_8h-source.html#l00128">DECISION</a>, <a class="el" href="netcode_8c-source.html#l00386">define_expected_data()</a>, <a class="el" href="tables_8h-source.html#l00120">EXT</a>, <a class="el" href="tables_8h-source.html#l00130">FORWARD</a>, <a class="el" href="netcode_8c-source.html#l00149">forward()</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="tables_8h-source.html#l00067">high_redirection_table</a>, <a class="el" href="types_8h-source.html#l00180">conn_struct::hih</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="types_8h-source.html#l00164">conn_struct::key</a>, <a class="el" href="types_8h-source.html#l00165">conn_struct::key_ext</a>, <a class="el" href="types_8h-source.html#l00166">conn_struct::key_lih</a>, <a class="el" href="types_8h-source.html#l00127">hih_struct::lih_addr</a>, <a class="el" href="tables_8h-source.html#l00147">NOK</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, <a class="el" href="types_8h-source.html#l00208">pkt_struct::origin</a>, <a class="el" href="types_8h-source.html#l00124">hih_struct::port</a>, <a class="el" href="tables_8h-source.html#l00129">REPLAY</a>, <a class="el" href="types_8h-source.html#l00174">conn_struct::replay_id</a>, <a class="el" href="netcode_8c-source.html#l00270">reset_lih()</a>, <a class="el" href="types_8h-source.html#l00185">conn_struct::stat_time</a>, <a class="el" href="tables_8c-source.html#l00223">switch_state()</a>, and <a class="el" href="types_8h-source.html#l00182">conn_struct::target</a>.</p>

<p>Referenced by <a class="el" href="decision__engine_8c-source.html#l00275">DE_process_packet()</a>.</p>

</div>
</div><p>
<a class="anchor" name="276fea9304d0e44959fe383a8a015826"></a><!-- doxytag: member="tables.c::store_pkt" ref="276fea9304d0e44959fe383a8a015826" args="(struct conn_struct *conn, struct pkt_struct *pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int store_pkt           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structconn__struct.html">conn_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpkt__struct.html">pkt_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Store the current <a class="el" href="structpacket.html">packet</a> as part of the connection to replay it later. If this is the first <a class="el" href="structpacket.html">packet</a> of a communication, init its structure in the main B-Tree. 
<p>
store_pkt function <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pkt,:</em>&nbsp;</td><td>struct <a class="el" href="structpkt__struct.html" title="The meta information of a packet stored in the conn_struct connection structure.">pkt_struct</a> to work with </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>conn,:</em>&nbsp;</td><td>struct <a class="el" href="structconn__struct.html" title="The meta informations of a connection stored in the main Binary Tree.">conn_struct</a> to work with</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the position of the <a class="el" href="structpacket.html">packet</a> in the list in case of success, a negative value if storage has failed </dd></dl>

<p>
Lock the structure<p>
g_static_rw_lock_writer_lock (&amp;conn-&gt;lock);<p>
Append pkt to the singly-linked list of conn<p>
Get the <a class="el" href="structpacket.html">packet</a> position<p>
Unlock the structure<p>
g_static_rw_lock_writer_unlock (&amp;conn-&gt;lock); 
<p>References <a class="el" href="types_8h-source.html#l00177">conn_struct::BUFFER</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="types_8h-source.html#l00164">conn_struct::key</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, and <a class="el" href="types_8h-source.html#l00216">pkt_struct::position</a>.</p>

</div>
</div><p>
<a class="anchor" name="c710506076f7d599c11b9ee253507dbf"></a><!-- doxytag: member="tables.c::switch_state" ref="c710506076f7d599c11b9ee253507dbf" args="(struct conn_struct *conn, int new_state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int switch_state           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structconn__struct.html">conn_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>new_state</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="tables_8c-source.html#l00191">lookup_state()</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, and <a class="el" href="types_8h-source.html#l00172">conn_struct::state</a>.</p>

<p>Referenced by <a class="el" href="decision__engine_8c-source.html#l00275">DE_process_packet()</a>, <a class="el" href="netcode_8c-source.html#l00301">replay()</a>, and <a class="el" href="tables_8c-source.html#l00934">setup_redirection()</a>.</p>

</div>
</div><p>
<a class="anchor" name="23896331f26ea6a2d495f5eb08753976"></a><!-- doxytag: member="tables.c::test_honeypot_addr" ref="23896331f26ea6a2d495f5eb08753976" args="(char *key, int list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_honeypot_addr           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compare an IP with a list of honeypot addresses 
<p>
test_honeypot_addr<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>the</em>&nbsp;</td><td>key ip:port of the host we want to test in the list </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>the</em>&nbsp;</td><td>list we want to look into, either Low or High</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if the key is found in the list, anything else if not </dd></dl>

<p>
We extract the IP from the key<p>
small hack to be able to define matching pattern for multiple IP at once<p>
We convert the IP from char to int<p>
We test which list we want to search<p>
if the IP is detected in the list of low honeypot addresses<p>
We then test by increasing the size of the network progressively:<p>
if the IP is detected in the list of high honeypot addresses 
<p>References <a class="el" href="tables_8c-source.html#l00643">addr2int()</a>, <a class="el" href="tables_8h-source.html#l00073">high_honeypot_addr</a>, <a class="el" href="tables_8h-source.html#l00122">HIH</a>, <a class="el" href="tables_8h-source.html#l00121">LIH</a>, <a class="el" href="tables_8h-source.html#l00070">low_honeypot_addr</a>, <a class="el" href="tables_8h-source.html#l00147">NOK</a>, and <a class="el" href="tables_8h-source.html#l00140">OK</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Feb 9 10:46:08 2010 for honeybrid by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
