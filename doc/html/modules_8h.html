<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>honeybrid: modules.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>modules.h File Reference</h1><code>#include &lt;glib.h&gt;</code><br>
<code>#include &lt;openssl/evp.h&gt;</code><br>
<code>#include &quot;<a class="el" href="log_8h-source.html">log.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="tables_8h-source.html">tables.h</a>&quot;</code><br>

<p>
<div class="dynheader">
Include dependency graph for modules.h:</div>
<div class="dynsection">
<p><center><img src="modules_8h__incl.png" border="0" usemap="#modules.h_map" alt=""></center>
<map name="modules.h_map">
<area shape="rect" href="log_8h.html" title="log.h" alt="" coords="151,84,201,111"><area shape="rect" href="tables_8h.html" title="tables.h" alt="" coords="225,84,297,111"><area shape="rect" href="types_8h.html" title="types.h" alt="" coords="301,161,368,188"></map>
</div>

<p>
<div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dynsection">
<p><center><img src="modules_8h__dep__incl.png" border="0" usemap="#modules.hdep_map" alt=""></center>
<map name="modules.hdep_map">
<area shape="rect" href="types_8h.html" title="types.h" alt="" coords="727,84,793,111"><area shape="rect" href="decision__engine_8c.html" title="Decision Engine for honeybrid." alt="" coords="797,316,931,343"><area shape="rect" href="honeybrid_8c.html" title="Main File." alt="" coords="667,316,763,343"><area shape="rect" href="mod__control_8c.html" title="Source IP based control engine to rate limit high interaction honeypot." alt="" coords="5,316,117,343"><area shape="rect" href="mod__hash_8c.html" title="SHA 1 Module for honeybrid Decision Engine." alt="" coords="141,316,240,343"><area shape="rect" href="mod__random_8c.html" title="RANDOM module for honeybrid Decision Engine." alt="" coords="264,316,381,343"><area shape="rect" href="mod__source_8c.html" title="Source IP based filtering Module for honeybrid Decision Engine." alt="" coords="1072,316,1184,343"><area shape="rect" href="mod__counter_8c.html" title="Packet counter Module for honeybrid Decision Engine." alt="" coords="1135,239,1249,265"><area shape="rect" href="mod__yesno_8c.html" title="mod_yesno.c" alt="" coords="1273,239,1380,265"><area shape="rect" href="modules_8c.html" title="modules.c" alt="" coords="1556,84,1644,111"><area shape="rect" href="tables_8h.html" title="tables.h" alt="" coords="724,161,796,188"><area shape="rect" href="rules_8c.html" title="rules.c" alt="" coords="984,316,1048,343"><area shape="rect" href="netcode_8h.html" title="netcode.h" alt="" coords="319,239,404,265"><area shape="rect" href="decision__engine_8h.html" title="decision_engine.h" alt="" coords="873,239,1009,265"><area shape="rect" href="netcode_8c.html" title="Network functions file." alt="" coords="540,316,623,343"><area shape="rect" href="tables_8c.html" title="Information tables file." alt="" coords="405,316,477,343"><area shape="rect" href="log_8c.html" title="Log function for honeybrid." alt="" coords="529,239,580,265"><area shape="rect" href="pcap__tool_8c.html" title="Pcap function to record communications." alt="" coords="604,239,697,265"></map>
</div>

<p>
<a href="modules_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmod__args.html">mod_args</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnode.html">node</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="modules_8h.html#c5400410e3513d2fbea9b3a2421a2c21">init_modules</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">setup modules that need to be initialized  <a href="#c5400410e3513d2fbea9b3a2421a2c21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="modules_8h.html#6df156759566c2d091ef852a17e2fa78">run_module</a> (char *module_name, struct <a class="el" href="structmod__args.html">mod_args</a> args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">test of a new function to run module based on module name (without calling get_module)  <a href="#6df156759566c2d091ef852a17e2fa78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*)(struct <a class="el" href="structmod__args.html">mod_args</a>)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="modules_8h.html#c9236bf17aa49c868c168ecc5320aded">get_module</a> (char *modname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the module function pointer from name  <a href="#c9236bf17aa49c868c168ecc5320aded"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="modules_8h.html#3f39ac5d36f425de26ef1076cf613315">save_backup_handler</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function handles the automatic saving of modules to external files. It works by checking an array in which modules to save have been registered This array is updated after each module run.  <a href="#3f39ac5d36f425de26ef1076cf613315"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="modules_8h.html#6a6a789efa2db64ed2bbe9b223efb1b1">save_backup</a> (GKeyFile *data, char *filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function adds a module backup memory to a queue in order to be written to a file later.  <a href="#6a6a789efa2db64ed2bbe9b223efb1b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="modules_8h.html#6192a290b974369920784a792fc1044b">write_backup</a> (char *filename, GKeyFile *data, void *userdata)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function write a module backup memory to a file.  <a href="#6192a290b974369920784a792fc1044b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="modules_8h.html#21e60162c8153653075451d9b28b30e9">mod_yesno</a> (struct <a class="el" href="structmod__args.html">mod_args</a> args)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="modules_8h.html#795156c8425194442da9bb1a8182e1e0">mod_counter</a> (struct <a class="el" href="structmod__args.html">mod_args</a> args)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="modules_8h.html#2805c4311dbe90420de0b250ca5526c6">mod_random</a> (struct <a class="el" href="structmod__args.html">mod_args</a> args)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="modules_8h.html#0fd44992c8a5ca2986e094b98cf3aae8">init_mod_hash</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="modules_8h.html#edf338529f690a340c064411b4508648">mod_hash</a> (struct <a class="el" href="structmod__args.html">mod_args</a> args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">calculate a SHA1 hash value of a <a class="el" href="structpacket.html">packet</a> payload, and look for a possible match in a database of hashes. Parameters required: function = hash; backup = /etc/honeybrid/hash.tb  <a href="#edf338529f690a340c064411b4508648"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="modules_8h.html#a5515368d4d08af9fd292e8c414a58a5">mod_source</a> (struct <a class="el" href="structmod__args.html">mod_args</a> args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">check if the source IP has already been seen in a prior connection Parameters required: function = hash; backup = /etc/honeybrid/source.tb  <a href="#a5515368d4d08af9fd292e8c414a58a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="modules_8h.html#5aabf7b0a283d46e498be4caeaaab9af">mod_control</a> (struct <a class="el" href="structmod__args.html">mod_args</a> args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">calculate the number of packets sent by a same source over a given period of time. If too many packets are sent, following packets are rejected Parameters required: function = hash; backup = /etc/honeybrid/control.tb expiration = 600 max_packet = 1000  <a href="#5aabf7b0a283d46e498be4caeaaab9af"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GHashTable *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="modules_8h.html#dd440b33ade7f6a74cd11b868dad2f75">module_to_save</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const EVP_MD *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="modules_8h.html#bb7f2f40445a754241e3a2c1ebcd52b6">md</a></td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="c9236bf17aa49c868c168ecc5320aded"></a><!-- doxytag: member="modules.h::get_module" ref="c9236bf17aa49c868c168ecc5320aded" args="(char *modname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(*)(struct <a class="el" href="structmod__args.html">mod_args</a>) get_module           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>modname</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
return the module function pointer from name 
<p>
get_module <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>modname,:</em>&nbsp;</td><td>module name </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>function pointer to the module </dd></dl>

<p>References <a class="el" href="err_8c-source.html#l00076">errx()</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="mod__counter_8c-source.html#l00044">mod_counter()</a>, <a class="el" href="mod__hash_8c-source.html#l00095">mod_hash()</a>, <a class="el" href="mod__random_8c-source.html#l00047">mod_random()</a>, <a class="el" href="mod__source_8c-source.html#l00050">mod_source()</a>, and <a class="el" href="mod__yesno_8c-source.html#l00043">mod_yesno()</a>.</p>

<p>Referenced by <a class="el" href="rules_8c-source.html#l01176">yyparse()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0fd44992c8a5ca2986e094b98cf3aae8"></a><!-- doxytag: member="modules.h::init_mod_hash" ref="0fd44992c8a5ca2986e094b98cf3aae8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int init_mod_hash           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
init OpenSSL SHA-1 engine 
<p>References <a class="el" href="log_8h-source.html#l00100">H</a>, and <a class="el" href="mod__hash_8c-source.html#l00060">md</a>.</p>

<p>Referenced by <a class="el" href="modules_8c-source.html#l00054">init_modules()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c5400410e3513d2fbea9b3a2421a2c21"></a><!-- doxytag: member="modules.h::init_modules" ref="c5400410e3513d2fbea9b3a2421a2c21" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_modules           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
setup modules that need to be initialized 
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>create two functions to handle module backup to file:<ul>
<li>a function called by modules to add themselves to a backup queue</li><li>a timer event callback function to process the backup queue periodically, and save backups to files </li></ul>
</dd></dl>
<p>
init_modules 
<p>
create a thread that will save module memory every minute 
<p>References <a class="el" href="err_8c-source.html#l00076">errx()</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="mod__hash_8c-source.html#l00074">init_mod_hash()</a>, <a class="el" href="modules_8h-source.html#l00064">module_to_save</a>, and <a class="el" href="modules_8c-source.html#l00141">save_backup_handler()</a>.</p>

<p>Referenced by <a class="el" href="honeybrid_8c-source.html#l01009">main()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5aabf7b0a283d46e498be4caeaaab9af"></a><!-- doxytag: member="modules.h::mod_control" ref="5aabf7b0a283d46e498be4caeaaab9af" args="(struct mod_args args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mod_control           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmod__args.html">mod_args</a>&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
calculate the number of packets sent by a same source over a given period of time. If too many packets are sent, following packets are rejected Parameters required: function = hash; backup = /etc/honeybrid/control.tb expiration = 600 max_packet = 1000 
<p>
** MODULE CONTROL<p>
control <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pkts,struct</em>&nbsp;</td><td>that contain the <a class="el" href="structpacket.html">packet</a> to control </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>set</em>&nbsp;</td><td>result to 1 if rate limit reached, 0 otherwise </td></tr>
  </table>
</dl>

<p>
get the IP address from the <a class="el" href="structpacket.html">packet</a><p>
get the backup file for this module<p>
We can't decide<p>
get the backup file path for this module<p>
We can't decide<p>
get control parameters<p>
no value set for expiration, we go with the default one<p>
no value set for expiration, we go with the default one<p>
20 characters should be enough to hold even very large numbers<p>
counter<p>
first seen<p>
duration<p>
We check if we need to expire this entry<p>
counter<p>
first seen<p>
duration<p>
counter<p>
duration<p>
clean and exit 
<p>References <a class="el" href="modules_8h-source.html#l00053">node::arg</a>, <a class="el" href="types_8h-source.html#l00212">pkt_struct::conn</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="types_8h-source.html#l00213">pkt_struct::key_src</a>, <a class="el" href="modules_8h-source.html#l00040">mod_args::node</a>, <a class="el" href="log_8c-source.html#l00072">now()</a>, <a class="el" href="modules_8h-source.html#l00041">mod_args::pkt</a>, <a class="el" href="modules_8h-source.html#l00058">node::result</a>, and <a class="el" href="modules_8c-source.html#l00161">save_backup()</a>.</p>

<p>Referenced by <a class="el" href="modules_8c-source.html#l00069">run_module()</a>.</p>

</div>
</div><p>
<a class="anchor" name="795156c8425194442da9bb1a8182e1e0"></a><!-- doxytag: member="modules.h::mod_counter" ref="795156c8425194442da9bb1a8182e1e0" args="(struct mod_args args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mod_counter           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmod__args.html">mod_args</a>&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
** MODULE COUNTER<p>
mod_counter requires the configuration of the following mandatory parameter:<ul>
<li>"counter", number of <a class="el" href="structpacket.html">packet</a> to receive before accepting</li></ul>
<p>
mod_counter <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>args,struct</em>&nbsp;</td><td>that contain the <a class="el" href="structnode.html">node</a> and the datas to process </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>set</em>&nbsp;</td><td>result to 1 <a class="el" href="structpacket.html">packet</a> position match arg, 0 otherwise </td></tr>
  </table>
</dl>

<p>
We can't decide<p>
We accept this <a class="el" href="structpacket.html">packet</a><p>
We reject this <a class="el" href="structpacket.html">packet</a> 
<p>References <a class="el" href="modules_8h-source.html#l00053">node::arg</a>, <a class="el" href="types_8h-source.html#l00212">pkt_struct::conn</a>, <a class="el" href="types_8h-source.html#l00176">conn_struct::count_data_pkt_from_intruder</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="modules_8h-source.html#l00040">mod_args::node</a>, <a class="el" href="modules_8h-source.html#l00041">mod_args::pkt</a>, and <a class="el" href="modules_8h-source.html#l00058">node::result</a>.</p>

<p>Referenced by <a class="el" href="modules_8c-source.html#l00097">get_module()</a>, and <a class="el" href="modules_8c-source.html#l00069">run_module()</a>.</p>

</div>
</div><p>
<a class="anchor" name="edf338529f690a340c064411b4508648"></a><!-- doxytag: member="modules.h::mod_hash" ref="edf338529f690a340c064411b4508648" args="(struct mod_args args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mod_hash           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmod__args.html">mod_args</a>&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
calculate a SHA1 hash value of a <a class="el" href="structpacket.html">packet</a> payload, and look for a possible match in a database of hashes. Parameters required: function = hash; backup = /etc/honeybrid/hash.tb 
<p>
mod_hash <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>args,struct</em>&nbsp;</td><td>that contain the <a class="el" href="structnode.html">node</a> and the datas to process </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_data,not</em>&nbsp;</td><td>used</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>set</em>&nbsp;</td><td>result to 0 if datas's fingerprint is found in search table, 1 if not </td></tr>
  </table>
</dl>

<p>
First, we make sure that we have data to work on<p>
get the backup file for this module<p>
We can't decide<p>
get the backup file path for this module<p>
We can't decide<p>
get the IP address from the <a class="el" href="structpacket.html">packet</a><p>
get the destination port<p>
get the payload from the <a class="el" href="structpacket.html">packet</a><p>
replace all occurrences of IP addresses by a generic IP<p>
digest the payload<p>
Unknown hash, so we accept the <a class="el" href="structpacket.html">packet</a><p>
We check if we need to expire this entry<p>
Known hash but entry expired, so we accept the <a class="el" href="structpacket.html">packet</a><p>
Known hash, so we reject the <a class="el" href="structpacket.html">packet</a><p>
clean and exit 
<p>References <a class="el" href="modules_8h-source.html#l00053">node::arg</a>, <a class="el" href="types_8h-source.html#l00212">pkt_struct::conn</a>, <a class="el" href="types_8h-source.html#l00176">conn_struct::count_data_pkt_from_intruder</a>, <a class="el" href="types_8h-source.html#l00209">pkt_struct::data</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="mod__hash_8c-source.html#l00071">HASH_ASCII</a>, <a class="el" href="mod__hash_8c-source.html#l00070">HASH_BYTE</a>, <a class="el" href="mod__hash_8c-source.html#l00066">HASH_COUNTER</a>, <a class="el" href="mod__hash_8c-source.html#l00068">HASH_DURATION</a>, <a class="el" href="mod__hash_8c-source.html#l00067">HASH_FIRST_SEEN</a>, <a class="el" href="mod__hash_8c-source.html#l00069">HASH_PACKET</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="modules_8h-source.html#l00059">node::info_result</a>, <a class="el" href="types_8h-source.html#l00214">pkt_struct::key_dst</a>, <a class="el" href="mod__hash_8c-source.html#l00060">md</a>, <a class="el" href="modules_8h-source.html#l00040">mod_args::node</a>, <a class="el" href="log_8c-source.html#l00072">now()</a>, <a class="el" href="types_8h-source.html#l00207">pkt_struct::packet</a>, <a class="el" href="types_8h-source.html#l00077">packet::payload</a>, <a class="el" href="modules_8h-source.html#l00041">mod_args::pkt</a>, <a class="el" href="modules_8h-source.html#l00058">node::result</a>, and <a class="el" href="modules_8c-source.html#l00161">save_backup()</a>.</p>

<p>Referenced by <a class="el" href="modules_8c-source.html#l00097">get_module()</a>, and <a class="el" href="modules_8c-source.html#l00069">run_module()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2805c4311dbe90420de0b250ca5526c6"></a><!-- doxytag: member="modules.h::mod_random" ref="2805c4311dbe90420de0b250ca5526c6" args="(struct mod_args args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mod_random           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmod__args.html">mod_args</a>&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
** MODULE RANDOM<p>
mod_random requires the configuration of the following mandatory parameter:<ul>
<li>"value", to define a basis for the probability to accept the <a class="el" href="structpacket.html">packet</a>, which is 1 out of value</li></ul>
<p>
mod_random <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>args,struct</em>&nbsp;</td><td>that contain the <a class="el" href="structnode.html">node</a> and the data to process </td></tr>
  </table>
</dl>

<p>
getting the value provided as parameter<p>
We can't decide<p>
We can't decide<p>
deciding based on a probability of 1 out of "value":<p>
We accept this <a class="el" href="structpacket.html">packet</a><p>
We reject this <a class="el" href="structpacket.html">packet</a> 
<p>References <a class="el" href="modules_8h-source.html#l00053">node::arg</a>, <a class="el" href="types_8h-source.html#l00212">pkt_struct::conn</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="modules_8h-source.html#l00040">mod_args::node</a>, <a class="el" href="modules_8h-source.html#l00041">mod_args::pkt</a>, and <a class="el" href="modules_8h-source.html#l00058">node::result</a>.</p>

<p>Referenced by <a class="el" href="modules_8c-source.html#l00097">get_module()</a>, and <a class="el" href="modules_8c-source.html#l00069">run_module()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a5515368d4d08af9fd292e8c414a58a5"></a><!-- doxytag: member="modules.h::mod_source" ref="a5515368d4d08af9fd292e8c414a58a5" args="(struct mod_args args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mod_source           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmod__args.html">mod_args</a>&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
check if the source IP has already been seen in a prior connection Parameters required: function = hash; backup = /etc/honeybrid/source.tb 
<p>
** MODULE SOURCE<p>
mod_source <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>args,struct</em>&nbsp;</td><td>that contain the <a class="el" href="structnode.html">node</a> and the data to process </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_data,not</em>&nbsp;</td><td>used</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>set</em>&nbsp;</td><td>result to 0 if attacker ip is found in search table, 1 if not </td></tr>
  </table>
</dl>

<p>
get the IP address from the <a class="el" href="structpacket.html">packet</a><p>
get the backup file for this module<p>
We can't decide<p>
get the backup file path for this module<p>
We can't decide<p>
Unknown IP, so we accept the <a class="el" href="structpacket.html">packet</a><p>
20 characters should be enough to hold even very large numbers<p>
counter<p>
first seen<p>
duration<p>
We check if we need to expire this entry<p>
Known IP but entry expired, so we accept the <a class="el" href="structpacket.html">packet</a><p>
counter<p>
first seen<p>
duration<p>
Known IP, so we reject the <a class="el" href="structpacket.html">packet</a><p>
counter<p>
duration<p>
clean and exit 
<p>References <a class="el" href="modules_8h-source.html#l00053">node::arg</a>, <a class="el" href="types_8h-source.html#l00212">pkt_struct::conn</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="types_8h-source.html#l00213">pkt_struct::key_src</a>, <a class="el" href="modules_8h-source.html#l00040">mod_args::node</a>, <a class="el" href="log_8c-source.html#l00072">now()</a>, <a class="el" href="modules_8h-source.html#l00041">mod_args::pkt</a>, <a class="el" href="modules_8h-source.html#l00058">node::result</a>, and <a class="el" href="modules_8c-source.html#l00161">save_backup()</a>.</p>

<p>Referenced by <a class="el" href="modules_8c-source.html#l00097">get_module()</a>, and <a class="el" href="modules_8c-source.html#l00069">run_module()</a>.</p>

</div>
</div><p>
<a class="anchor" name="21e60162c8153653075451d9b28b30e9"></a><!-- doxytag: member="modules.h::mod_yesno" ref="21e60162c8153653075451d9b28b30e9" args="(struct mod_args args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mod_yesno           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmod__args.html">mod_args</a>&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
************ [Basic Modules]<p>
** MODULE YESNO<p>
mod_yesno requires the configuration of the following mandatory parameter:<ul>
<li>"value", if 0 it rejects everything, if 1 it accepts everything</li></ul>
<p>
mod_yesno <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>args,struct</em>&nbsp;</td><td>that contain the <a class="el" href="structnode.html">node</a> and the datas to process</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>set</em>&nbsp;</td><td>result to 1 when 'arg' is "yes", 0 otherwise </td></tr>
  </table>
</dl>

<p>
We can't decide<p>
We accept this <a class="el" href="structpacket.html">packet</a><p>
We reject this <a class="el" href="structpacket.html">packet</a> 
<p>References <a class="el" href="modules_8h-source.html#l00053">node::arg</a>, <a class="el" href="types_8h-source.html#l00212">pkt_struct::conn</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="modules_8h-source.html#l00040">mod_args::node</a>, <a class="el" href="modules_8h-source.html#l00041">mod_args::pkt</a>, and <a class="el" href="modules_8h-source.html#l00058">node::result</a>.</p>

<p>Referenced by <a class="el" href="modules_8c-source.html#l00097">get_module()</a>, and <a class="el" href="modules_8c-source.html#l00069">run_module()</a>.</p>

</div>
</div><p>
<a class="anchor" name="6df156759566c2d091ef852a17e2fa78"></a><!-- doxytag: member="modules.h::run_module" ref="6df156759566c2d091ef852a17e2fa78" args="(char *module_name, struct mod_args args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void run_module           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>module_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structmod__args.html">mod_args</a>&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
test of a new function to run module based on module name (without calling get_module) 
<p>
run_module 
<p>References <a class="el" href="types_8h-source.html#l00212">pkt_struct::conn</a>, <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="types_8h-source.html#l00173">conn_struct::id</a>, <a class="el" href="mod__control_8c-source.html#l00048">mod_control()</a>, <a class="el" href="mod__counter_8c-source.html#l00044">mod_counter()</a>, <a class="el" href="mod__hash_8c-source.html#l00095">mod_hash()</a>, <a class="el" href="mod__random_8c-source.html#l00047">mod_random()</a>, <a class="el" href="mod__source_8c-source.html#l00050">mod_source()</a>, <a class="el" href="mod__yesno_8c-source.html#l00043">mod_yesno()</a>, <a class="el" href="modules_8h-source.html#l00040">mod_args::node</a>, <a class="el" href="modules_8h-source.html#l00041">mod_args::pkt</a>, and <a class="el" href="modules_8h-source.html#l00058">node::result</a>.</p>

<p>Referenced by <a class="el" href="decision__engine_8c-source.html#l00196">decide()</a>.</p>

</div>
</div><p>
<a class="anchor" name="6a6a789efa2db64ed2bbe9b223efb1b1"></a><!-- doxytag: member="modules.h::save_backup" ref="6a6a789efa2db64ed2bbe9b223efb1b1" args="(GKeyFile *data, char *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int save_backup           </td>
          <td>(</td>
          <td class="paramtype">GKeyFile *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>filename</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function adds a module backup memory to a queue in order to be written to a file later. 
<p>
save_backup 
<p>References <a class="el" href="log_8h-source.html#l00100">H</a>, and <a class="el" href="modules_8h-source.html#l00064">module_to_save</a>.</p>

<p>Referenced by <a class="el" href="mod__control_8c-source.html#l00048">mod_control()</a>, <a class="el" href="mod__hash_8c-source.html#l00095">mod_hash()</a>, and <a class="el" href="mod__source_8c-source.html#l00050">mod_source()</a>.</p>

</div>
</div><p>
<a class="anchor" name="3f39ac5d36f425de26ef1076cf613315"></a><!-- doxytag: member="modules.h::save_backup_handler" ref="3f39ac5d36f425de26ef1076cf613315" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void save_backup_handler           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function handles the automatic saving of modules to external files. It works by checking an array in which modules to save have been registered This array is updated after each module run. 
<p>
save_backup_handler 
<p>
saving module every 60 seconds 
<p>References <a class="el" href="log_8h-source.html#l00100">H</a>, <a class="el" href="modules_8h-source.html#l00064">module_to_save</a>, <a class="el" href="tables_8h-source.html#l00140">OK</a>, <a class="el" href="tables_8h-source.html#l00039">threading</a>, and <a class="el" href="modules_8c-source.html#l00118">write_backup()</a>.</p>

<p>Referenced by <a class="el" href="modules_8c-source.html#l00054">init_modules()</a>.</p>

</div>
</div><p>
<a class="anchor" name="6192a290b974369920784a792fc1044b"></a><!-- doxytag: member="modules.h::write_backup" ref="6192a290b974369920784a792fc1044b" args="(char *filename, GKeyFile *data, void *userdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write_backup           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GKeyFile *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userdata</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function write a module backup memory to a file. 
<p>
write_backup 
<p>References <a class="el" href="log_8h-source.html#l00100">H</a>.</p>

<p>Referenced by <a class="el" href="modules_8c-source.html#l00141">save_backup_handler()</a>.</p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="bb7f2f40445a754241e3a2c1ebcd52b6"></a><!-- doxytag: member="modules.h::md" ref="bb7f2f40445a754241e3a2c1ebcd52b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const EVP_MD* <a class="el" href="modules_8h.html#bb7f2f40445a754241e3a2c1ebcd52b6">md</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
*********** [Advanced Modules]<p>
** MODULE HASH 
</div>
</div><p>
<a class="anchor" name="dd440b33ade7f6a74cd11b868dad2f75"></a><!-- doxytag: member="modules.h::module_to_save" ref="dd440b33ade7f6a74cd11b868dad2f75" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GHashTable* <a class="el" href="modules_8h.html#dd440b33ade7f6a74cd11b868dad2f75">module_to_save</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="modules_8c-source.html#l00054">init_modules()</a>, <a class="el" href="modules_8c-source.html#l00161">save_backup()</a>, and <a class="el" href="modules_8c-source.html#l00141">save_backup_handler()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Feb 9 10:46:07 2010 for honeybrid by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
